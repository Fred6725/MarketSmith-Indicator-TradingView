// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// 

//@version=5
indicator("MarketSmith Indicator", overlay=true, max_bars_back = 253, max_lines_count = 100)

//------------------  BARS PART ---------------------//
// Color of bars
prevClose   = input(true, title='Color Based On Previous Close',  group="----------BARS----------", inline="x")
i_posColor = input(color.rgb(0, 0, 255)   , title='Candle Color Positive', group="----------BARS----------", inline = "1")
i_negColor = input(color.rgb(222,50,174,0), title='Negative', group="----------BARS----------", inline = "1")
colorCandle = close>=open ? i_posColor:i_negColor
if(prevClose)
    colorCandle := close>=close[1] ? i_posColor:i_negColor
// Full Body (without border without wick)
plotcandle(low, high, low, high, title='MarketSmith Bars', color = colorCandle, wickcolor = color.rgb(255,255,255,100), bordercolor = color.rgb(255,255,255,100), editable = true)
// PlotChar - on close
plotchar(close, char='-', location=location.absolute, size=size.small, color=colorCandle, editable = true)

//------------------  SMA's PART ---------------------//
// Input SMA for Daily TF and others
iSma10    = input(true, title='MA 1',  group="----------SMAs----------", inline="sma10")
iSmaV10   = input(10, title='Lenght',  group="----------SMAs----------", inline="sma10")
iExp10    = input(true, title='Exponential',  group="----------SMAs----------", inline="sma10")
iCol10    = input(color.rgb(68,186,76), title="", group="----------SMAs----------", inline="sma10")
iSma21    = input(true, title='MA 2',  group="----------SMAs----------", inline="sma21")
iSmaV21   = input(21, title='Lenght',  group="----------SMAs----------", inline="sma21")
iExp21    = input(true, title='Exponential',  group="----------SMAs----------", inline="sma21")
iCol21    = input(color.rgb(240,141,240,0), title="", group="----------SMAs----------", inline="sma21")
iSma50    = input(true, title='MA 3',  group="----------SMAs----------", inline="sma50")
iSmaV50   = input(50, title='Lenght',  group="----------SMAs----------", inline="sma50")
iExp50    = input(false, title='Exponential',  group="----------SMAs----------", inline="sma50")
iCol50    = input(color.rgb(255,33,33), title="", group="----------SMAs----------", inline="sma50")
iSma200   = input(true, title='MA 4', group="----------SMAs----------", inline="sma200")
iSmaV200  = input(200, title='Lenght',  group="----------SMAs----------", inline="sma200")
iExp200   = input(false, title='Exponential',  group="----------SMAs----------", inline="sma200")
iCol200    = input(color.rgb(0,0,0,0), title="", group="----------SMAs----------", inline="sma200")

// Input SMA for Weekly TimeFrame
iSma10We    = input(true, title='SMA 1',  group="----------SMAs We----------", inline="sma10We")
iSmaV10We   = input(10, title='Lenght',  group="----------SMAs We----------", inline="sma10We")
iExp10We    = input(false, title='Exponential',  group="----------SMAs We----------", inline="sma10We")
iCol10We    = input(color.rgb(255,33,33), title="", group="----------SMAs We----------", inline="sma10We")
iEma20We    = input(true, title='EMA 2',  group="----------SMAs We----------", inline="ema20We")
iSmaV20We   = input(20, title='Lenght',  group="----------SMAs We----------", inline="ema20We")
iExp20We    = input(true, title='Exponential',  group="----------SMAs We----------", inline="ema20We")
iCol20We    = input(color.rgb(240,141,240,0), title="", group="----------SMAs We----------", inline="ema20We")
iSma30We    = input(true, title='SMA 3',  group="----------SMAs We----------", inline="sma30We")
iSmaV30We   = input(30, title='Lenght',  group="----------SMAs We----------", inline="sma30We")
iExp30We    = input(false, title='Exponential',  group="----------SMAs We----------", inline="sma30We")
iCol30We    = input(color.rgb(68,186,76), title="", group="----------SMAs We----------", inline="sma30We")
iSma40We    = input(true, title='SMA 4',  group="----------SMAs We----------", inline="sma40We")
iSmaV40We   = input(40, title='Lenght',  group="----------SMAs We----------", inline="sma40We")
iExp40We    = input(false, title='Exponential',  group="----------SMAs We----------", inline="sma40We")
iCol40We    = input(color.rgb(0,0,0,0), title="", group="----------SMAs We----------", inline="sma40We")


// SMA calculation Daily & others TF
sma10  = iExp10  ? ta.ema(close,iSmaV10) :ta.sma(close,iSmaV10)
sma21  = iExp21  ? ta.ema(close,iSmaV21) :ta.sma(close,iSmaV21)
sma50  = iExp50  ? ta.ema(close,iSmaV50) :ta.sma(close,iSmaV50)
sma200 = iExp200 ? ta.ema(close,iSmaV200):ta.sma(close,iSmaV200)

// SMA calculation We
sma10We  = iExp10We ? ta.ema(close,iSmaV10We):ta.sma(close,iSmaV10We)
ema20We  = iExp20We ? ta.ema(close,iSmaV20We):ta.sma(close,iSmaV20We)
sma30We  = iExp30We ? ta.ema(close,iSmaV30We):ta.sma(close,iSmaV30We)
sma40We  = iExp40We ? ta.ema(close,iSmaV40We):ta.sma(close,iSmaV40We)

// Ploting SMA/EMA Daily and other TF
tfWeekly = timeframe.isweekly
psma10  = plot(iSma10 and not tfWeekly ?  sma10:na,  linewidth=1, color=iCol10)
pema21  = plot(iSma21 and not tfWeekly ?  sma21:na,  linewidth=1, color=iCol21)
psma50  = plot(iSma50 and not tfWeekly ?  sma50:na,  linewidth=1, color=iCol50)
psma200 = plot(iSma200 and not tfWeekly ? sma200:na, linewidth=1, color=iCol200)

// Ploting SMA/EMA We
psma10We =  plot(iSma10We and tfWeekly  ? sma10We:na, linewidth=1, color=iCol10We)
pema20We =  plot(iEma20We and tfWeekly  ? ema20We:na, linewidth=1, color=iCol20We)
psma30We =  plot(iSma30We and tfWeekly  ? sma30We:na, linewidth=1, color=iCol30We)
psma40We =  plot(iSma40We and tfWeekly  ? sma40We:na, linewidth=1, color=iCol40We)

//------------------  RS Line Part  ---------------------// and // SP500 -> 0S&P5 //

//Relative Price Strength (RS) Rating or Relative Strenght.
//This is a measure of a stock's price performance over the last
//twelve months, compared to all stocks in IBD's Database.
//The rating scale ranges frome 1 (lowest) to 99 (highest)
//At least this is the IBD proprietary rating's defintion.
//Let's create an equivalent here for TradingView!
//
// © RaviYendru thanks for providing the intial script
// Fred6724 - Let's see if it is possible to get better results

hideRSLine  = input(false, title="Hide RS Line", group="----------RS Rating----------", inline="0")
hideRSRat   = input(false, title="Hide Rating", group = "----------RS Rating----------", inline="0")
//seedetail   = input(false, title="Display the 3 results", group = "Parameters", inline="0")
src         = close
comparativeTickerId = input("SP:SPX", title="Comparative Symbol", group = "----------RS Rating----------", tooltip = "Reference ticker used for calculation of the RS Line and RS Score.")
SpxValue    = input(4400, title="Value of Comparative Symbol", group = "----------RS Rating----------", tooltip = "Used to display the RS Line under the price. If you modify the ticker, please report its value in this box.")
offset      = input.int(80, minval = 0, maxval = 300, title="Offset (%)", group = "----------RS Rating----------", tooltip = "Used to display the RS Line under the price.")
colorRS     = input(color.rgb(0, 0, 255), title = "Color of RS Line & Rating", group = "----------RS Rating----------")
plotNewHigh = input(false, title = "Plot RS New Highs", group = "----------RS Rating----------")
rsNewHigh   = input.string("Historical RS New Highs", title = "Type", options=["RS New Highs","RS New Highs Before Price", "Historical RS New Highs", "Historical RS New Highs  Before Price"], group = "----------RS Rating----------")
blueDotCol  = input(color.rgb(121, 213, 242,62), title = "Color of Dots", group = "----------RS Rating----------")
lookback    = input.int(252, title = "Look-back", minval = 1, maxval = 252, group = "----------RS Rating----------", tooltip = "The lookback for calculation of price and RS New Highs.")
sizeLabHigh = input.string('Normal', title = 'Size', options = ['Tiny', 'Small', 'Normal', 'Large'], group = "----------RS Rating----------")
plotNewLow  = input(false, title = "Plot RS New Lows", group = "----------RS Rating----------")
rsNewLow    = input.string("Historical RS New Lows", title = "Type", options=["RS New Lows","RS New Lows Before Price", "Historical RS New Lows", "Historical RS New Lows  Before Price"], group = "----------RS Rating----------")
redDotCol   = input(color.rgb(255, 82, 82, 62), title = "Color", group = "----------RS Rating----------")
lookback2   = input.int(252, title = "Look-back", minval = 1, maxval = 252, group = "----------RS Rating----------", tooltip = "The lookback for calculation of price and RS New Lows.")
sizeLabLow  = input.string('Normal', title = 'Size', options = ['Tiny', 'Small', 'Normal', 'Large'], group = "----------RS Rating----------")
boolMa      = input(false, title = "Display MA", group = "MA on RS Line")
lenMa       = input(21, title = "Lenght Da", group = "MA on RS Line", inline = "c")
colMa       = input(color.orange, title = "Color", group = "MA on RS Line", inline = "c")
typMa       = input.string("EMA", title = "Type Da", options = ["SMA", "EMA"], group = "MA on RS Line", inline = "c")
lenMaWe     = input(10, title = "Lenght We", group = "MA on RS Line", inline = "c")
typMaWe     = input.string("SMA", title = "Type We", options = ["SMA", "EMA"], group = "MA on RS Line", inline = "c")
fillMa      = input(false, title = "Area Color", group = "MA on RS Line")
posCol      = input(color.rgb(0, 230, 119, 75), title = "Positive Area", group = "MA on RS Line", inline = "d")
negCol      = input(color.rgb(255, 82, 82, 75),  title = "Negative Area", group = "MA on RS Line", inline = "d")

// Blue Dot
// If Blue Dot is ste to 252 Da, than we want it to be set on 52 We on the Weekly TimeFrame
if (lookback  == 252 and timeframe.isweekly)
    lookback  := 52
if (lookback2 == 252 and timeframe.isweekly)
    lookback2 := 52

// Switch Label Size
highLabel = switch sizeLabHigh
    'Normal'  => size.normal
    'Tiny'    => size.tiny
    'Small'   => size.small
    'Large'   => size.large

lowLabel  = switch sizeLabLow
    'Normal'  => size.normal
    'Tiny'    => size.tiny
    'Small'   => size.small
    'Large'   => size.large

// Using bar index in case of IPO to avoid NaN results
// Added max_bars_max = 253 to improve display speed
n63      = bar_index < 63  ? bar_index:63 
n126     = bar_index < 126 ? bar_index:126
n189     = bar_index < 189 ? bar_index:189
n252     = bar_index < 252 ? bar_index:252


// Comparative Ticker for RS Line
comparativeSymbol   = request.security(comparativeTickerId, timeframe.period, close)
// RS Line but multiplied by a little bit less than the constant value of the comparative ticker for correct display
rsCurve             = (src/comparativeSymbol)
// We use a wider offset for Weekly timeframe for a smoother display
rsRatio             = timeframe.isweekly ? SpxValue*(offset-10)/100:SpxValue*offset/100
rs                  = rsCurve*rsRatio
prevlookback  = lookback
prevlookback2 = lookback2 // For RS New Lows
lookback := math.min(lookback - 1, bar_index)
rsPlot = plot(hideRSLine ? na:rs, title="RS Line", style=plot.style_line, linewidth=1, color=colorRS)

// MA on RS Line
// SMA and EMA
rsMA      = ta.sma(rs, lenMa)
if(typMa == "SMA" and not timeframe.isweekly)
    rsMA      := ta.sma(rs, lenMa)
if(typMa == "EMA" and not timeframe.isweekly)  
    rsMA      := ta.ema(rs, lenMa)
if(typMaWe == "SMA" and timeframe.isweekly)
    rsMA      := ta.sma(rs, lenMaWe)
if(typMaWe == "EMA" and timeframe.isweekly)
    rsMA      := ta.ema(rs, lenMaWe)

maPlot    = plot(boolMa ? rsMA :na,    color = colMa, linewidth = 1)

// Color Filling
// I will use an invisible MA to be able to choose or not the display of the fill
maPlot2    = plot(boolMa and fillMa ? rsMA:na,    color = color.rgb(0,0,0,100), linewidth = 1)
// This variable gets the color that will be used for the fill
fillCol = rs > rsMA ? posCol:negCol
// Here if a MA is missing, there is no fill
fill(rsPlot, maPlot2 ,   color=fillCol)



// Historical New Highs & New Highs Before Price
var label newHigh = na
histNH = ta.highest(rs  , prevlookback)
histCl = ta.highest(high, prevlookback)
// Historical RS New High
if(rsNewHigh == "Historical RS New Highs" and plotNewHigh and rs == histNH)
    newHigh := label.new(x = bar_index, y = rs, color = blueDotCol, style = label.style_circle, size = highLabel)
// Historical RS New High Before Price
if(rsNewHigh == "Historical RS New Highs  Before Price" and plotNewHigh and rs == histNH and high < histCl)
    newHigh := label.new(x = bar_index, y = rs, color = blueDotCol, style = label.style_circle, size = highLabel)
// RS New High
if(barstate.islast and rsNewHigh == "RS New Highs" and plotNewHigh and rs == histNH)
    label.delete(newHigh)
    newHigh := label.new(x = bar_index, y = rs, color = blueDotCol, style = label.style_circle, size = highLabel)
// RS New High Before Price
if(barstate.islast and rsNewHigh == "RS New Highs Before Price" and plotNewHigh and rs == histNH and high < histCl)
    label.delete(newHigh)
    newHigh := label.new(x = bar_index, y = rs, color = blueDotCol, style = label.style_circle, size = highLabel)


// Historical New Lows & New Lows Before Price
var label newLow  = na
histNL  = ta.lowest(rs , prevlookback2)
histClL = ta.lowest(low, prevlookback2)
// Historical RS New Low
if(rsNewLow == "Historical RS New Lows" and plotNewLow and rs == histNL)
    newLow := label.new(x = bar_index, y = rs, color = redDotCol, style = label.style_circle, size = lowLabel)
// Historical RS New Low Before Price
if(rsNewLow == "Historical RS New Lows  Before Price" and plotNewLow and rs == histNL and low > histClL)
    newLow := label.new(x = bar_index, y = rs, color = redDotCol, style = label.style_circle, size = lowLabel)
// RS New Low
if(barstate.islast and rsNewLow == "RS New Lows" and plotNewLow and rs == histNL)
    label.delete(newLow)
    newLow := label.new(x = bar_index, y = rs, color = redDotCol, style = label.style_circle, size = lowLabel)
// RS New Low Before Price
if(barstate.islast and rsNewLow == "RS New Lows Before Price" and plotNewLow and rs == histNL and low > histClL)
    label.delete(newLow)
    newLow := label.new(x = bar_index, y = rs, color = redDotCol, style = label.style_circle, size = lowLabel)



// Calculation of the RS Rating
// Getting ticker and reference ticker daily data
closeDa    = request.security(syminfo.tickerid,    'D', close)
spxCloseDa = request.security(comparativeTickerId, 'D', close)

// Calculation of the performance from 1 to 4 last quarters
// Ticker
perfTicker63   = closeDa/closeDa[n63]
perfTicker126  = closeDa/closeDa[n126]
perfTicker189  = closeDa/closeDa[n189]
perfTicker252  = closeDa/closeDa[n252]

// SP500 of reference ticker
perfComp63     = spxCloseDa/spxCloseDa[n63]
perfComp126    = spxCloseDa/spxCloseDa[n126]
perfComp189    = spxCloseDa/spxCloseDa[n189]
perfComp252    = spxCloseDa/spxCloseDa[n252]

// Using Formula to calculate a relative score of the ticker and the SP500 with the last quarter weighted double
float rs_stock = 0.4*perfTicker63 + 0.2*perfTicker126 + 0.2*perfTicker189 + 0.2*perfTicker252
float rs_ref   = 0.4*perfComp63   + 0.2*perfComp126   + 0.2*perfComp189   + 0.2*perfComp252

// Calculation of the total relative score or rs performance
float totalRsScore  = (rs_stock) / (rs_ref) * 100
float totalRsRating = -1

// Here we calculated the relative score of the stock. The goal is now to assign the percentile correctly
// For this I took the curve given by my fork repo of Skyte on Rs Log and tried to calibrate the better possible
// the output curve of the relative performance of the 6,6xx stocks.
// Link: https://github.com/Fred6725/rs-log/blob/main/output/rs_stocks.csv
// Here is the curve in ASCII Art; on the x-axis, the Rs Rating and on the y-axis, the calculated performance.
      
//                      
//                                                                                        /                               
//                                                                                        /                               
//                                                                                        /                               
//                                                                                        /                               
//,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,/,,,,,,,,,,,,,,,,,              
//                                                                                        /                               
//                                                                                        /                               
//                                                                                        /                               
//                                                                                        /                               
//                                                                                       |                               
//                                                                                       /                               
//                                                                                      ‾                                 
//                                                                                     ‾                                   
//                                                                                   -‾                                    
//                                                                           _____, ‾                                     
//                                         _____----------------‾‾‾‾‾‾‾‾‾‾‾‾‾                                                   
//                        __ */‾‾‾‾‾‾‾‾‾‾‾‾                                                                                       
//             __ ,,----‾‾                                                                                                 
//          _/                                                                                                           
//        /                                                                                                               
//       |                                                                                                     
// ______|________________ _______________________________ _____________________________________            
//       |0               |20             |40             |60             |80              |100   
//
// I decided to cut this curve in 7 different levels that needs to be entered each day.
// These are relative strength scores corresponding to percentiles 98, 89, 69, 49, 29, 9 and 1.
// Finally I used the request.seed() function to auto update these levels automatically on a daily basis.
// Everything is managed in this repo if you're curious:
// https://github.com/Fred6725/relative-strength/tree/main    (Fork from Skyte)
// More precisly in rs_ranking.py for extracting what I needed and in workflows/output.yml for the auto update.
// The update is done in the private fork of the seed tradingview original repo, checked and synchronised automatically
// I tried to uplad the full 6,6xx list of relative strength score and rs rating but the display speed was too long.


// Use the request.seed() function to access the RS Score environment of all the market
curveRsPerf  = request.seed("seed_fred6725_rs_rating", "RSRATING", close)

// To prevent loosing data because of week-ends and public holidays I decided to send the value 5 times in a row.
// Which gives 5*7 = 35 bars.
// Depending of the day we look at the graph we will have a variable amount of bars. 
// The goal is to get these 7 numbers anyway.

// In case the graph is not updated, we count the number of bars since we have the first data.
// Calculation of the number of bar since we have the first data
delta  = ta.barssince(na(curveRsPerf)!=true)

// Table to store the different values
var float[] different_values = array.new_float(7)

// Counter for stored values
var int counter = 0

// Browse seed's values and store the first 7 different values
for i = delta to 34+delta
    close_value = nz(curveRsPerf[i])
    if not array.includes(different_values, close_value) and counter < 7 and close_value!=0
        array.set(different_values, counter, close_value)
        counter := counter + 1

// Assign stored values to variables
first = array.get(different_values, 0)
scnd  = array.get(different_values, 1)
thrd  = array.get(different_values, 2)
frth  = array.get(different_values, 3)
ffth  = array.get(different_values, 4)
sxth  = array.get(different_values, 5)
svth  = array.get(different_values, 6)

// Now that we've recovered the environment, we can assign a percentile using a simple linear approximation of the curve (+ adjustment).
if(totalRsScore >= first)
    totalRsRating := 99
if(totalRsScore <= svth)
    totalRsRating := 1

// Function to attribute the percentile with a simple linear approximation
f_attributePercentile(totalRsScore, tallerPerf, smallerPerf, rangeUp, rangeDn, weight) =>
    sum = totalRsScore + (totalRsScore-smallerPerf)*weight // weight is used for manual calibration
    if(sum > tallerPerf - 1)
        sum := tallerPerf - 1
    k1 = smallerPerf/rangeDn
    k2 = (tallerPerf-1)/rangeUp
    k3 = (k1-k2)/(tallerPerf-1-smallerPerf)
    RsRating = sum/(k1-k3*(totalRsScore-smallerPerf))
    if (RsRating > rangeUp)
        RsRating := rangeUp
    if (RsRating < rangeDn)
        RsRating := rangeDn
    RsRating

// Between 199 & 120 the score where approx 98 to 90.
if(totalRsScore < first and totalRsScore >= scnd)
    totalRsRating := f_attributePercentile(totalRsScore, first, scnd, 98, 90, 0.33)
// Between 119 and 100 we ave scores between 89 and 70.
if (totalRsScore < scnd and totalRsScore >= thrd)
    totalRsRating := f_attributePercentile(totalRsScore, scnd, thrd, 89, 70, 2.1)
// Between 100 and 91 we ave scores between 69 and 50.
if (totalRsScore < thrd and totalRsScore >= frth)
    totalRsRating := f_attributePercentile(totalRsScore, thrd, frth, 69, 50, 0)
// Between 90 and 82 we ave scores between 49 and 30.
if (totalRsScore < frth and totalRsScore >= ffth)
    totalRsRating := f_attributePercentile(totalRsScore, frth, ffth, 49, 30, 0)
// Between 81 and 56 we ave scores between 29 and 10.
if (totalRsScore < ffth and totalRsScore >= sxth)
    totalRsRating := f_attributePercentile(totalRsScore, ffth, sxth, 29, 10, 0)
// Between 55 and 28 we ave scores between 9 and 2.
if (totalRsScore < sxth and totalRsScore >= svth)
    totalRsRating := f_attributePercentile(totalRsScore, sxth, svth, 9, 2, 0)


// Display the RS Rating
// The results can only be used in Daily TimeFrame
isDaily = timeframe.isdaily
labelText1 = "RS Rating"
labelText2 = ""
// Here we want to display 'RS' without value if one of the constants is missing
if(isDaily and totalRsRating != -1)
    labelText2 := "\n\n"+str.tostring(totalRsRating,"#0")
// Display the labels
label1 = (hideRSRat == false) and barstate.islast ? label.new(bar_index, rs, text=labelText1 , color = color.rgb(0,0,0,100), size=size.normal, textcolor=colorRS, style=label.style_label_left, textalign=text.align_left, yloc=yloc.price) : na
label2 = (hideRSRat == false) and barstate.islast ? label.new(bar_index, rs, text=labelText2 , color = color.rgb(0,0,0,100), size=size.large, textcolor=colorRS, style=label.style_label_left, textalign=text.align_left, yloc=yloc.price) : na

// Delete previous Labels (When new candle opens or when replay mode, the labels were piling on)
label.delete(label1[1])
label.delete(label2[1])


// Weekly Tight Closes Detector
//input
WtClose          = input(false, title='Weekly Tight Closes Detector', group="TIGHT CLOSES DETECTOR")
colorTightCloses = input(color.aqua, title='Color of Tight Closes Boxes', group="TIGHT CLOSES DETECTOR")
// Calculation
if(tfWeekly)
    // Open
    WkO2   = open[2]
    //Closes
    WkC    = close
    WkC1   = close[1]
    WkC2   = close[2]
    // Highs
    WkH    = high
    WkH1   = high[1]
    WkH2   = high[2]
    // Lows
    WkL    = low
    WkL1   = low[1]
    WkL2   = low[2]
    // WEMA
    Wema10 = ta.ema(close,10)
    Wema20 = ta.ema(close,20)
    // ATR Weekly (Used to have an auto-adaptive tight closes detector. Formula = Averages High-Low of the 14 previous bars. (Volatility measurement)
    atr    = ta.atr(14)
    // Conditions (I like to have 3 tiny candle with tight closes so I add High and Low cond as well)
    condTightClose = WkC < WkC1+(WkC1*atr/(close*2)) and WkC > WkC1-(WkC1*atr/(close*2)) and WkC1 < WkC2+(WkC2*atr/(close*2)) and WkC1 > WkC2-(WkC2*atr/(close*2)) and WkC < WkC2+(WkC2*atr/(close*2)) and WkC > WkC2-(WkC2*atr/(close*2))
    condTightHigh = WkH < WkH1+(WkH1*atr/(close*2)) and WkH > WkH1-(WkH1*atr/(close*2)) and WkH1 < WkH2+(WkH2*atr/(close*2)) and WkH1 > WkH2-(WkH2*atr/(close*2))
    condTightLow = WkL < WkL1+(WkL1*atr/(close*2)) and WkL > WkL1-(WkL1*atr/(close*2)) and WkL1 < WkL2+(WkL2*atr/(close*2)) and WkL1 > WkL2-(WkL2*atr/(close*2))
    //condNotLowerLows  = WkL2 > WkL1 and WkL1 > WkL
    // I would like the script not to show me 3 tight candles when the first candle of the three is nearly full and big
    // For that I wrote that the total size of the weekly wick of the candle must be 2 times bigger than the body
    // But I noticed somtimes very small candle with little or no wick are still valide so added an exception ! (Yes it is far-fetched)
    condFirstCandle = false
    // For positive bars
    if(WkC2 >= WkO2)
        condFirstCandle := WkH2 - WkC2 + WkO2 - WkL2 > 2*(WkC2 - WkO2) or (WkH2-WkL2<WkH1-WkL1)
    // For negative bars
    if(WkC2 < WkO2)
        condFirstCandle := WkH2 - WkO2 + WkC2 - WkL2 > 2*(WkO2 - WkC2) or (WkH2-WkL2<WkH1-WkL1)
    // All condition together
    condTot3WTight = condTightClose and (condTightHigh or condTightLow) and condFirstCandle //and not condNotLowerLows


    //Plot Boxes Arround Weekly Tight Closes
    highestW = ta.highest(WkH,3)
    lowestW  = ta.lowest (WkL,3)
    if(condTot3WTight and WtClose)
        box.new(bar_index[2], highestW, bar_index, lowestW, border_color = color.new(colorTightCloses,20), border_width = 1, border_style=line.style_dotted, bgcolor = color.new(colorTightCloses,85))



//------------------  Marked Highs and Lows  ---------------------//

// Price Peak/Valley Points
// Highlights exact price at high or low points over a 19-period interval.
// For example, on a Daily chart, a High Price point is marked on the date
// where there has been no higher price the 9 days prior to that date and
// the 9 days following that date.

// Inputs
i_displayHL = input(true, title="Display H/L Points", group="High/Low Price Points")
i_colorHL   = input(color.rgb(0,0,0,0), title='Labels Color', group="High/Low Price Points")
i_displayPc = input(false, title="%Change", group='High/Low Price Points')
i_colorPctP = input(color.rgb(0, 0, 255), title='Positive % Color', group="High/Low Price Points", inline = "z")
i_colorPctN = input(color.rgb(222,50,174,0), title='Negative %', group="High/Low Price Points", inline = "z")
i_pivot     = input(9, title="Length for peak/valey points", group="High/Low Price Points")

// Definr arrays to store pivot values
var pivotHighValues = array.new_float(0)
var pivotLowValues  = array.new_float(0)

if(i_displayHL and not tfWeekly)
    // Use the function ta.pivothigh/low()
    pivotHigh = ta.pivothigh(high, i_pivot, i_pivot)
    pivotLow  = ta.pivotlow (low,  i_pivot, i_pivot)
    // High Price Point
    if(pivotHigh)
        array.unshift(pivotHighValues, high[i_pivot])
        textHigh9   = i_displayPc ? str.tostring(high[i_pivot], '0.00')+'\n':str.tostring(high[i_pivot], '0.00')
        highestHigh = label.new(bar_index-i_pivot, array.get(pivotHighValues, 0), xloc=xloc.bar_index, yloc=yloc.price, style=label.style_none, text=textHigh9, textcolor=i_colorHL)
    // Low Price Point
    if(pivotLow)
        array.unshift(pivotLowValues, low[i_pivot])    //low[i_pivot]
        textLow9    = "\n" + str.tostring(low[i_pivot], '0.00')
        lowestLow   = label.new(bar_index-i_pivot, array.get(pivotLowValues, 0), xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_center, text=textLow9, textcolor=i_colorHL, color=color.rgb(0,0,0,100))
    // Percentage Variation
    float pHigh = na
    float pLow  = na
    if array.size(pivotHighValues) > 0
        pHigh := array.get(pivotHighValues, 0)
    if array.size(pivotLowValues) > 0
        pLow  := array.get(pivotLowValues, 0)
    prcVarHigh = (pHigh - pLow)/pLow * 100
    prcVarLow  = (pLow/pHigh - 1) * 100  // Formula to calculate percentage decline
    prcVarHighText = prcVarHigh>=0 ? '+'+str.tostring(prcVarHigh, '0.0') + '%':str.tostring(prcVarHigh, '0.0') + '%'
    prcVarLowText  = prcVarLow>=0 ? '+'+str.tostring(prcVarLow , '0.0') + '%':str.tostring(prcVarLow, '0.0') + '%'
    colorPctUp = prcVarHigh>=0 ? i_colorPctP:i_colorPctN
    colorPctDn = prcVarLow >=0 ? i_colorPctP:i_colorPctN
    // High Price Point Percent Variation 
    if(pivotHigh and i_displayPc)
        pctPivotHigh = na(prcVarHigh)==true ? na:label.new(bar_index-i_pivot, array.get(pivotHighValues, 0), xloc=xloc.bar_index, yloc=yloc.price, style=label.style_none, text=prcVarHighText, textcolor=colorPctUp)
    if(pivotLow and i_displayPc)
        pctPivotLow  = na(prcVarLow)==true ? na:label.new(bar_index-i_pivot, array.get(pivotLowValues, 0), xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_center, text="\n\n\n" + prcVarLowText, textcolor=colorPctDn, color=color.rgb(0,0,0,100))




//------------------  Chart Pattern Recognition  ---------------------//


// INPUTS
i_displayPattern         = input(true, title='Display Pattern'                , group='Chart Pattern Recognition')
i_displayBoxes           = input(true, title='Display Trade Boxes'            , group='Chart Pattern Recognition')
i_displayHistoricalBoxes = input(false, title='Display Historical Trade Boxes' , group='Chart Pattern Recognition')

// ARRAYS
// Define arrays to store pivot values6
// PIVOTS
var pivotHighValuesC = array.new_float(0)
var pivotLowValuesC  = array.new_float(0)
// BASE PATTERN
var int baseBeginingX   = 0
var baseBeginingY   = array.new_float(0)
var lowOfBase       = array.new_float(0)
var pivotHighValuesLow  = array.new_float(0)
var pivotHighBar        = array.new_int(0)
var pivotLowBar         = array.new_int(0)
// DOUBLE BOTTOM PATTERN
var highOfDoubleBottom  = array.new_float(0)
var lowOfDoubleBottom   = array.new_float(0)
var int DBBeginingX     = 0


// PIVOTS HIGH/LOW
// Use the function ta.pivothigh/low() and store values in arrays
pivotHigh = ta.pivothigh(high, i_pivot, i_pivot)
pivotLow  = ta.pivotlow (low,  i_pivot, i_pivot)
if (pivotHigh)
    array.unshift(pivotHighValuesC, high[i_pivot])
    array.unshift(pivotHighValuesLow, low[i_pivot])
    array.unshift(pivotHighBar, bar_index[i_pivot])
if (pivotLow)
    array.unshift(pivotLowValuesC, low[i_pivot])
    array.unshift(pivotLowBar, bar_index[i_pivot])


// Detection of a Pivot High for the detection of the base
boolHighbase   = false
boolHigherPiv  = false
highestOfBase  = ta.highest(high, 25 )
highestOfHist  = ta.highest(high, 50 )
lowestBaseLow  = ta.lowest (low , 25 )
lowestPointLeg = ta.lowest (low , 103)
var flatBaseCond   = false
isFlatBase         = false


// CONDITIONS FOR BASE DETECTION
if(array.size(pivotHighValuesC) > 2)
    // In case the base is made of multiple Pivots High without Pivot Low
    boolHighbase  := high[25]==array.get(pivotHighValuesC, 0) or  high[25]==array.get(pivotHighValuesC, 1) or high[25]==array.get(pivotHighValuesC, 2)
    boolHigherPiv := high[25]>=highestOfHist
    // Minimal Leg Up Calculation
    legUp     = lowestPointLeg * (15+100)/100
    legUpCond = high[25] >= legUp
    // Maximal Base Depth
    firstBaseDepth = high[25] * (100-35)/100 <= lowestBaseLow
    // No candle is above high[25]
    noCandleAbove = highestOfBase <= high[25]
    // Every Conditions with spikes for detection
    flatBaseCond := boolHighbase and boolHigherPiv and legUpCond and firstBaseDepth and noCandleAbove

// If Base Detected we store key points
if (flatBaseCond and not isFlatBase[1])
    array.unshift(baseBeginingY, high[25])
    baseBeginingX := bar_index[25]
    array.unshift(lowOfBase    , lowestBaseLow)

// Bool for Actual base that stay at 1 while the base is still valid
if (flatBaseCond or isFlatBase[1])
    isFlatBase := true


// Candle Base Counter
var float baseCount    = na
// When a base is detected, reset the bar count
if (flatBaseCond and not isFlatBase[1])
    baseCount := bar_index-baseBeginingX
// Increment the bar count if we are in a base
if (isFlatBase)
    baseCount := baseCount + 1

// Check if the base is still valid
float pivotBase  = 0
float bottomBase = 0
if (array.size(baseBeginingY)>0 and array.size(lowOfBase)>0)
    pivotBase  := array.get(baseBeginingY, 0)
    bottomBase := array.get(lowOfBase    , 0)
condBaseDepthExceeded = (pivotBase*(100-35)/100 >= lowestBaseLow)
if (isFlatBase)
    if (high>pivotBase)
        isFlatBase := false
    if (low<bottomBase and not condBaseDepthExceeded)
        array.unshift(lowOfBase, low)
    if (condBaseDepthExceeded)
        isFlatBase := false


// Maintenance
// plot(isFlatBase ? 135:130, color=color.lime)
// plot(baseCount, color=color.red)
// plot(flatBaseCond ? 65:50, color=color.purple)
// Detail of Detection Spike
// plot(legUpCond ? 9:6, color=color.red)
// plot(firstBaseDepth ? 9:6, color=color.blue)
// plot(noCandleAbove ? 9:6, color=color.purple)

// Boolean for Box Gestion
isBox   = false
boxOver = true
if(isBox[1] and not boxOver[1])
    isBox := true

// CONDITIONS FOR DOUBLE BOTTOM DETECTION
detectDoubleBottom = false
if(isFlatBase)
    if (array.size(pivotHighValuesC) > 1 and array.size(pivotLowValuesC) > 1)
        firstPivHigh = array.get(pivotHighValuesC, 1)
        scndPivHigh  = array.get(pivotHighValuesC, 0)
        firstPivLow  = array.get(pivotLowValuesC, 1)
        scndPivLow   = array.get(pivotLowValuesC, 0)
        // Price Conditions
        condPricesA  = firstPivHigh > scndPivHigh and firstPivLow > scndPivLow and firstPivLow < scndPivHigh
        condPricesB  = scndPivLow >= 0.6 * firstPivHigh
        condPricesC  = scndPivLow <= 0.9 * firstPivHigh
        condPricesD  = (firstPivHigh-scndPivLow) * 0.6 + scndPivLow <= scndPivHigh // Buy point is above 60% of the base
        condPricesE  = (firstPivHigh-scndPivLow) * 0.9 + scndPivLow >= scndPivHigh // Buy point is at least under 10% of the high of the base
        condPricesF  = (firstPivHigh-firstPivLow)/(scndPivHigh-scndPivLow) >= 0.75
        // Assigned in order of Time
        firstPivTime = array.get(pivotHighBar, 1)
        scndPivTime  = array.get(pivotLowBar, 1)
        thrdPivTime  = array.get(pivotHighBar, 0)
        frthPivTime  = array.get(pivotLowBar, 0)
        // Time Conditions
        condTimeA    = firstPivTime < scndPivTime and scndPivTime < thrdPivTime and thrdPivTime < frthPivTime
        condTimeB    = frthPivTime - firstPivTime <= 100
        condTimeC    = (thrdPivTime-firstPivTime) * 2 >= (bar_index-thrdPivTime) // Pattern Propreties A-C x 2 > E-D
        condTimeD    = (thrdPivTime-firstPivTime) <= (bar_index-thrdPivTime) * 2 // Same as above but for the other side
        if (condPricesA and condPricesB and condPricesC and condPricesD and condPricesE and condPricesF and condTimeA and condTimeB and condTimeC and condTimeD)
            detectDoubleBottom := true
            array.unshift(lowOfDoubleBottom, scndPivLow)
            array.unshift(highOfDoubleBottom, firstPivHigh)
            DBBeginingX := array.get(pivotHighBar, 1)

// Boolean to store the information
isDoubleBottom = false
if (detectDoubleBottom or isDoubleBottom[1])
    isDoubleBottom := true

// Maintenance
// plot(detectDoubleBottom ? 139:120, color=color.red)
// plot(isDoubleBottom ? 145:140, color=color.blue)

// Graphical Objects Declaration
// Horizontal Lines
var line highLine = na
var line lowLine  = na
var line dbLine1  = na
var line dbLine2  = na
var line dbLine3  = na

// Box for Entry/Take Profit/ SL
var box entryBox = na
var box slBox    = na
var box tpBox    = na


// DRAWING ON CHART IF DETECTION
if (flatBaseCond and not isFlatBase[1] and timeframe.isdaily and i_displayPattern)
    highLine := line.new(x1=baseBeginingX, y1=array.get(baseBeginingY, 0), x2=bar_index, y2=array.get(baseBeginingY, 0), width=3, style = line.style_dotted, color=color.rgb(146,193,131,0))
    lowLine  := line.new(x1=baseBeginingX, y1=array.get(lowOfBase    , 0), x2=bar_index, y2=array.get(lowOfBase   , 0),  width=2, style = line.style_solid,  color=color.rgb(146,193,131,0))
    select = i_displayHistoricalBoxes ? false:boxOver
    // Optional Trade Boxes
    if(select)
        box.delete(entryBox)
        box.delete(slBox)
        box.delete(tpBox)
        isBox   := false
        boxOver := true

// DRAWING DOUBLE BOTTOM ON CHART IF DETECTION
if (detectDoubleBottom and not isDoubleBottom[1]  and timeframe.isdaily and i_displayPattern)
    line.delete(highLine)
    line.delete(lowLine )
    highLine := line.new(x1=array.get(pivotHighBar, 0), y1=array.get(pivotHighValuesC, 0), x2=bar_index, y2=array.get(pivotHighValuesC, 0), width=3, style = line.style_dotted, color=color.rgb(146,193,131,0))
    dbLine1 := line.new(x1=array.get(pivotHighBar, 1), y1=array.get(pivotHighValuesLow, 1)*(100-1)/100, x2=array.get(pivotLowBar,  1), y2=array.get(pivotLowValuesC,  1)*(100-1)/100    , width=2, style = line.style_solid, color=color.rgb(146,193,131,0))
    dbLine2 := line.new(x1=array.get(pivotLowBar,  1), y1=array.get(pivotLowValuesC,     1)*(100-1)/100, x2=array.get(pivotHighBar, 0), y2=array.get(pivotHighValuesLow, 0)*(100-1)/100 , width=2, style = line.style_solid, color=color.rgb(146,193,131,0))
    dbLine3 := line.new(x1=array.get(pivotHighBar, 0), y1=array.get(pivotHighValuesLow, 0)*(100-1)/100, x2=array.get(pivotLowBar,  0), y2=array.get(pivotLowValuesC, 0)*(100-1)/100     , width=2, style = line.style_solid, color=color.rgb(146,193,131,0))
    lowLine := line.new(x1=array.get(pivotLowBar,  0), y1=array.get(pivotLowValuesC,     0)*(100-1)/100, x2=bar_index                 , y2=low*(100-1)/100                    , width=2, style = line.style_solid, color=color.rgb(146,193,131,0))
    select = i_displayHistoricalBoxes ? false:boxOver
    // Optional Trade Boxes
    if(select)
        box.delete(entryBox)
        box.delete(slBox)
        box.delete(tpBox)
        isBox   := false
        boxOver := true

// Check Top Break
if (high>line.get_y1(highLine) and (isFlatBase[1] or isDoubleBottom[1]))
    isFlatBase := false  
    if (isDoubleBottom)
        isDoubleBottom := false
    if(i_displayBoxes)
        topBase   = line.get_y1(highLine)
        entryBox := box.new(bar_index[1], topBase*(1+0.05), bar_index, topBase         , border_color=color.rgb(0,0,0,100), border_width=0, bgcolor=color.rgb(0,0,255,92))
        slBox    := box.new(bar_index[1], topBase*(1-0.05), bar_index, topBase*(1-0.08), border_color=color.rgb(0,0,0,100), border_width=0, bgcolor=color.rgb(255, 0, 0, 92))
        tpBox    := box.new(bar_index[1], topBase*(1+0.20), bar_index, topBase*(1+0.25), border_color=color.rgb(0,0,0,100), border_width=0, bgcolor=color.rgb(66, 226, 18, 92))
        isBox    := true
        boxOver  := false

// Check Bottom Break
// Adjust Double Bottom Base
if (array.size(lowOfDoubleBottom) > 0)
    if (low < array.get(lowOfDoubleBottom, 0) and isDoubleBottom)
        line.delete(highLine)
        line.delete(lowLine )
        line.delete(dbLine1 )
        line.delete(dbLine2 )
        line.delete(dbLine3 )
        isDoubleBottom := false
        // Redraw Original base if Double Bottom disabled
        highLine := line.new(x1=baseBeginingX, y1=array.get(baseBeginingY, 0), x2=bar_index, y2=array.get(baseBeginingY, 0), width=3, style = line.style_dotted, color=color.rgb(146,193,131,0))
        lowLine  := line.new(x1=baseBeginingX, y1=low                        , x2=bar_index, y2=low                        ,  width=2, style = line.style_solid,  color=color.rgb(146,193,131,0))
// Check Double Bottom base Length
if (isDoubleBottom and bar_index-DBBeginingX>100)
    line.delete(highLine)
    line.delete(lowLine )
    line.delete(dbLine1 )
    line.delete(dbLine2 )
    line.delete(dbLine3 )
    isDoubleBottom := false
// Check Double Bottom Pattern Propreties
firstPivTime = line.get_x1(dbLine1)
thrdPivTime  = line.get_x2(dbLine2)
if (isDoubleBottom and (thrdPivTime-firstPivTime) * 2 <= bar_index-thrdPivTime or (thrdPivTime-firstPivTime) >= (bar_index-thrdPivTime) * 2)
    line.delete(highLine)
    line.delete(lowLine )
    line.delete(dbLine1 )
    line.delete(dbLine2 )
    line.delete(dbLine3 )
    isDoubleBottom := false
    // Redraw Original base if Double Bottom disabled
    highLine := line.new(x1=baseBeginingX, y1=array.get(baseBeginingY, 0), x2=bar_index, y2=array.get(baseBeginingY, 0), width=3, style = line.style_dotted, color=color.rgb(146,193,131,0))
    lowLine  := line.new(x1=baseBeginingX, y1=low                        , x2=bar_index, y2=low                        ,  width=2, style = line.style_solid,  color=color.rgb(146,193,131,0))

// Adjust Bottom of Base
if (low < line.get_y1(lowLine) and isFlatBase and not isDoubleBottom)
    line.set_y1(lowLine, low)
    line.set_y2(lowLine, low)
// Check Max Depth and Max Length
if ((low < line.get_y1(highLine) * (100-35)/100 or baseCount>75) and isFlatBase[1] and not isDoubleBottom[1])
    line.delete(highLine)
    line.delete(lowLine)
    isFlatBase    := false
// Check Depth of base to adjust style of line (Depth above 20% = Dotted Line)
if (line.get_y1(highLine) * 0.8 >= line.get_y1(lowLine) and isFlatBase and not isDoubleBottom)
    line.set_style(lowLine, line.style_dotted)
    line.set_width(lowLine, 3)
// While the base is still valid, we extend lines
if (high<=line.get_y1(highLine) and low>=line.get_y1(lowLine) and isFlatBase)
    line.set_x2(highLine, bar_index)
    if (isDoubleBottom)
        line.set_y2(lowLine, low*(100-1)/100)
    line.set_x2(lowLine,  bar_index)
    

// TRADE BOX GESTION
// Extend Boxes while the trade runs
if (high<=line.get_y1(highLine)*(1+0.25) and low>=line.get_y1(highLine)*(1-0.08) and isBox) 
    box.set_right(entryBox, bar_index)
    box.set_right(slBox   , bar_index)
    box.set_right(tpBox   , bar_index)
    isBox   := true
    boxOver := false
