// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// 

//@version=5
indicator("MarketSmith Indicator", overlay=true)


//------------------  SMA's PART ---------------------//
// Input SMA for Daily TF and others
largerSMA = input(false, title="Larger SMA")
iSma10    = input(true, title='MA 10',  group="----------SMAs----------", inline="sma10")
iSorS10   = input.string(defval ='EMA 10', title='MA 10', options=['SMA 10', 'EMA 10'], group="----------SMAs----------", inline="sma10")
iSma21    = input(true, title='MA 21',  group="----------SMAs----------", inline="sma21")
iSorS21   = input.string(defval ='EMA 21', title='MA 21', options=['SMA 21', 'EMA 21'], group="----------SMAs----------", inline="sma21")
iSma50    = input(true, title='MA 50',  group="----------SMAs----------", inline="sma50")
iSma200   = input(true, title='MA 200', group="----------SMAs----------", inline="sma200")

// Input SMA for Weekly TimeFrame
iSma10We    = input(true, title='SMA 10 We',  group="----------SMAs We----------", inline="sma10We")
iSorS10We   = input.string(defval ='SMA 10 We', title='MA 10 We', options=['SMA 10 We', 'EMA 10 We'], group="----------SMAs We----------", inline="sma10We")
iEma20We    = input(true, title='EMA 20 We',  group="----------SMAs We----------", inline="ema20We")
iSorS20We   = input.string(defval ='SMA 20 We', title='MA 20 We', options=['SMA 20 We', 'EMA 20 We'], group="----------SMAs We----------", inline="ema20We")
iSma30We    = input(true, title='SMA 30 We',  group="----------SMAs We----------", inline="sma30We")
iSma40We    = input(true, title='SMA 40 We',  group="----------SMAs We----------", inline="sma40We")


// SMA calculation Daily & others TF
sma10  = iSorS10 == 'SMA 10' ? ta.sma(close,10):ta.ema(close,10)
sma21  = iSorS21 == 'SMA 21' ? ta.sma(close,21):ta.ema(close,21)
sma50  = ta.sma(close,50)
sma200 = ta.sma(close,200)

// SMA calculation We
sma10We  = iSorS10We == 'SMA 10 We' ? ta.sma(close,10):ta.ema(close,10)
ema20We = iSorS20We == 'SMA 21 We' ? ta.sma(close,20):ta.ema(close,20)
sma30We  = ta.sma(close,30)
sma40We  = ta.sma(close,40)

// Ploting SMA/EMA Daily and other TF
tfWeekly = timeframe.isweekly
psma10  = plot(iSma10 and not tfWeekly ?  sma10:na,  linewidth=largerSMA ? 2:1, color=color.rgb(68,186,76))
pema21  = plot(iSma21 and not tfWeekly ?  sma21:na,  linewidth=largerSMA ? 2:1, color=color.rgb(236,180,245,0))
psma50  = plot(iSma50 and not tfWeekly ?  sma50:na,  linewidth=largerSMA ? 2:1, color=color.red)
psma200 = plot(iSma200 and not tfWeekly ? sma200:na, linewidth=largerSMA ? 2:1, color=color.rgb(0,0,0,0))

// Ploting SMA/EMA We
psma10We =  plot(iSma10We and tfWeekly  ? sma10We:na, linewidth=largerSMA ? 2:1, color=color.red)
pema20We =  plot(iEma20We and tfWeekly  ? ema20We:na, linewidth=largerSMA ? 2:1, color=color.rgb(240,141,240,0))
psma30We =  plot(iSma30We and tfWeekly  ? sma30We:na, linewidth=largerSMA ? 2:1, color=color.rgb(102,144,78,0))
psma40We =  plot(iSma40We and tfWeekly  ? sma40We:na, linewidth=largerSMA ? 2:1, color=color.rgb(0,0,0,0))

//------------------  RS Line Part  ---------------------// and // SP500 -> 0S&P5 //

//Relative Price Strength (RS) Rating or Relative Strenght.
//This is a measure of a stock's price performance over the last
//twelve months, compared to all stocks in IBD's Database.
//The rating scale ranges frome 1 (lowest) to 99 (highest)
//At least this is the IBD proprietary rating's defintion.
//Let's create an equivalent here for TradingView!
//
// © RaviYendru thanks for providing the intial script
// Fred6724 - Let's see if it is possible to get better results
hideRSLine  = input(false, title="Hide RS Line", group="----------RS Rating----------", inline="0")
hideRSRat   = input(false, title="Hide Rating", group = "----------RS Rating----------", inline="0")
src         = close
comparativeTickerId = input("SP:SPX", title="Comparative Symbol", group = "----------RS Rating----------")
SpxValue    = input(3900, title="Value of Comparative Symbol", group = "----------RS Rating----------")
colorRS     = input(color.rgb(0, 0, 255), title = "Color of RS Line & Rating", group = "----------RS Rating----------")


// SMA method
W1Ma        = 40
W2Ma        = 20
W3Ma        = 20
W4Ma        = 20
//Classic perf method
W1P         = 40
W2P         = 20
W3P         = 20
W4P         = 20
//Spx
spxW1Ma     = 40
spxW2Ma     = 20
spxW3Ma     = 20
spxW4Ma     = 20
// Final
w1          = 2
w2          = 1
w3          = 1


// Comparative Ticker for RS Line
// Line 15 is declared the input for the comparative ticker
comparativeSymbol   = request.security(comparativeTickerId, timeframe.period, close)
//plot(comparativeSymbol*1.2*kclose/3900, color=color.rgb(0,0,0,0))
// RS Line but multiplied by a little bit less than the constant value of the comparative ticker for correct display
rs                  = timeframe.isweekly ? src/comparativeSymbol * SpxValue*0.50:src/comparativeSymbol * SpxValue*0.80
plot(hideRSLine ? na:rs, title="RS Line", style=plot.style_line, linewidth=1, color=colorRS)


// New Calculation model -- EXPERIMENTAL
// I will combine 3 methods
// The first one will calculate how the stock behave vs SMA thanks to tickers showing % of stock above (200,150,100,50,20)
// The second method will be an adaptation of the classic way that is provided to calculate RS Rating Perf close vs close 3M back (detail on the formula below)
// The third will be a measure of how the stock perform against the comparative Symbol
// For all these 3 techniques I will be using the formula delivered by IBD: RS Score = 40% * P3 + 20% * P6 + 20% * P9 + 20% * P12
//
// Finally I will try to calibrate the result for it to be at least relevant. I'm not aiming for 100% accuracy at all.
// In fact considering the tools we have on tradingview this is not possible to be 100% accurate.
// Don't hesitate to modify constants or calculation and try to find best results :) If you find a better result than me please contact me!


// 1ST METHOD
// Tickers I will use
// MMTH - %Stock > 200 Da SMA
// MMOF - %Stock > 150 Da SMA
// MMOH - %Stock > 100 Da SMA
// MMFI - %Stock > 50 Da SMA
// MMTW - %Stock > 20 Da SMA
// MMFD - %Stock > 5 Da SMA (more or less only noise, I won't use the 5 Daily SMA)

//                 |Formula                     | Here I use this code to limite 75% up and 25% down regarding number of stock above SMA X
limitDown = 25                               // | This limitation will allow me to calculate a theorical max & min to limit the result to 99 & 1
limitUp   = 75
perStockAbove200 = request.security("MMTH", 'D', close) > limitUp ? limitUp:request.security("MMTH", 'D', close) < limitDown ? limitDown:request.security("MMTH", 'D', close)
perStockAbove150 = request.security("MMOF", 'D', close) > limitUp ? limitUp:request.security("MMOF", 'D', close) < limitDown ? limitDown:request.security("MMOF", 'D', close)
perStockAbove100 = request.security("MMOH", 'D', close) > limitUp ? limitUp:request.security("MMOH", 'D', close) < limitDown ? limitDown:request.security("MMOH", 'D', close)
perStockAbove50  = request.security("MMFI", 'D', close) > limitUp ? limitUp:request.security("MMFI", 'D', close) < limitDown ? limitDown:request.security("MMFI", 'D', close)
perStockAbove20  = request.security("MMTW", 'D', close) > limitUp ? limitUp:request.security("MMTW", 'D', close) < limitDown ? limitDown:request.security("MMTW", 'D', close)

// The goal is to gather as much data as possible as we can't compare the score relatively to every other ticker. We do an approximation based on SMA and % of stock above them at X moment.
closeDa = request.security(syminfo.tickerid, 'D', close)
// SMA Declaration based on SMA Daily on the ticker we're watching
sma200_2 = request.security(syminfo.tickerid, 'D', ta.sma(closeDa,200))
sma150 = request.security(syminfo.tickerid, 'D', ta.sma(closeDa,150))
sma100 = request.security(syminfo.tickerid, 'D', ta.sma(closeDa,100))
sma50_2  = request.security(syminfo.tickerid, 'D', ta.sma(closeDa,50))
sma20  = request.security(syminfo.tickerid, 'D', ta.sma(closeDa,20))
// Daily Close SPX500
spxCloseDa = request.security("SP:SPX", 'D', close)
// We save if we were above dedicated moving averages in a boolean variable
// Reference point ticker
bCloseAbove200 = closeDa > sma200_2 ? 1:0
bCloseAbove150 = closeDa > sma150 ? 1:0
bCloseAbove100 = closeDa > sma100 ? 1:0
bCloseAbove50  = closeDa > sma50_2  ? 1:0
bCloseAbove20  = closeDa > sma20  ? 1:0
// Refence 63 days back (3 months)
bClose63Above200 = closeDa[63] > sma200_2[63] ? 1:0
bClose63Above150 = closeDa[63] > sma150[63] ? 1:0
bClose63Above100 = closeDa[63] > sma100[63] ? 1:0
bClose63Above50  = closeDa[63] > sma50_2[63]  ? 1:0
bClose63Above20  = closeDa[63] > sma20[63]  ? 1:0
// Refence 126 days back (6 months)
bClose126Above200 = closeDa[126] > sma200_2[126] ? 1:0
bClose126Above150 = closeDa[126] > sma150[126] ? 1:0
bClose126Above100 = closeDa[126] > sma100[126] ? 1:0
bClose126Above50  = closeDa[126] > sma50_2[126]  ? 1:0
bClose126Above20  = closeDa[126] > sma20[126]  ? 1:0
// Refence 189 days back (9 months)
bClose189Above200 = closeDa[189] > sma200_2[189] ? 1:0
bClose189Above150 = closeDa[189] > sma150[189] ? 1:0
bClose189Above100 = closeDa[189] > sma100[189] ? 1:0
bClose189Above50  = closeDa[189] > sma50_2[189]  ? 1:0
bClose189Above20  = closeDa[189] > sma20[189]  ? 1:0
// Refence 252 days back (12 months)
bClose252Above200 = closeDa[252] > sma200_2[252] ? 1:0
bClose252Above150 = closeDa[252] > sma150[252] ? 1:0
bClose252Above100 = closeDa[252] > sma100[252] ? 1:0
bClose252Above50  = closeDa[252] > sma50_2[252]  ? 1:0
bClose252Above20  = closeDa[252] > sma20[252]  ? 1:0
// Calculation based on the formula: RS Score = 40% * P3 + 20% * P6 + 20% * P9 + 20% * P12
// I choosed to calculate like this: if we were above this moving average when only 20% of stock were above, we get 1/0.20 = higher score because it is more noticeable.
// The same when we are below the moving average whereas 80% of stocks are above, we loose the same amont with the formula 1/(1-0.8)
// 0 MONTHS RS
zeroMonthsma200_2Weight = bCloseAbove200 ? 100/(perStockAbove200):-100/(100-perStockAbove200)
zeroMonthSma150Weight = bCloseAbove150 ? 100/(perStockAbove150):-100/(100-perStockAbove150)  // 100-X% because if the same logic applies if we are exceptionnaly weak 100/(100-75) = 4 vs 1.33
zeroMonthSma100Weight = bCloseAbove100 ? 100/(perStockAbove100):-100/(100-perStockAbove100)
zeroMonthsma50_2Weight  = bCloseAbove50  ? 100/(perStockAbove50 ):-100/(100-perStockAbove50 )
zeroMonthSma20Weight  = bCloseAbove20  ? 100/(perStockAbove20 ):-100/(100-perStockAbove20 )
zeroMonthWeight       = zeroMonthsma200_2Weight + zeroMonthSma150Weight + zeroMonthSma100Weight + zeroMonthsma50_2Weight + zeroMonthSma20Weight
// 3 MONTHS RS 
threeMonthsma200_2Weight = bClose63Above200 ? 100/(perStockAbove200[63]):-100/(100-perStockAbove200[63])
threeMonthSma150Weight = bClose63Above150 ? 100/(perStockAbove150[63]):-100/(100-perStockAbove150[63])
threeMonthSma100Weight = bClose63Above100 ? 100/(perStockAbove100[63]):-100/(100-perStockAbove100[63])
threeMonthsma50_2Weight  = bClose63Above50  ? 100/(perStockAbove50[63] ):-100/(100-perStockAbove50[63] )
threeMonthSma20Weight  = bClose63Above20  ? 100/(perStockAbove20[63] ):-100/(100-perStockAbove20[63] )
threeMonthWeight       = threeMonthsma200_2Weight + threeMonthSma150Weight + threeMonthSma100Weight + threeMonthsma50_2Weight + threeMonthSma20Weight
// 6 MONTHS RS
sixMonthsma200_2Weight = bClose126Above200 ? 100/(perStockAbove200[126]):-100/(100-perStockAbove200[126]) 
sixMonthSma150Weight = bClose126Above150 ? 100/(perStockAbove150[126]):-100/(100-perStockAbove150[126])
sixMonthSma100Weight = bClose126Above100 ? 100/(perStockAbove100[126]):-100/(100-perStockAbove100[126])
sixMonthsma50_2Weight  = bClose126Above50  ? 100/(perStockAbove50[126] ):-100/(100-perStockAbove50[126] )
sixMonthSma20Weight  = bClose126Above20  ? 100/(perStockAbove20[126] ):-100/(100-perStockAbove20[126] )
sixMonthWeight       = sixMonthsma200_2Weight + sixMonthSma150Weight + sixMonthSma100Weight + sixMonthsma50_2Weight + sixMonthSma20Weight
// 9 MONTH RS
nineMonthsma200_2Weight = bClose189Above200 ? 100/(perStockAbove200[189]):-100/(100-perStockAbove200[189])   
nineMonthSma150Weight = bClose189Above150 ? 100/(perStockAbove150[189]):-100/(100-perStockAbove150[189])
nineMonthSma100Weight = bClose189Above100 ? 100/(perStockAbove100[189]):-100/(100-perStockAbove100[189])
nineMonthsma50_2Weight  = bClose189Above50  ? 100/(perStockAbove50[189] ):-100/(100-perStockAbove50[189] )
nineMonthSma20Weight  = bClose189Above20  ? 100/(perStockAbove20[189] ):-100/(100-perStockAbove20[189] )
nineMonthWeight       = nineMonthsma200_2Weight + nineMonthSma150Weight + nineMonthSma100Weight + nineMonthsma50_2Weight + nineMonthSma20Weight
// 12 MONTH RS
twelveMonthsma200_2Weight = bClose252Above200 ? 100/(perStockAbove200[252]):-100/(100-perStockAbove200[252])
twelveMonthSma150Weight = bClose252Above150 ? 100/(perStockAbove150[252]):-100/(100-perStockAbove150[252])
twelveMonthSma100Weight = bClose252Above100 ? 100/(perStockAbove100[252]):-100/(100-perStockAbove100[252])
twelveMonthsma50_2Weight  = bClose252Above50  ? 100/(perStockAbove50[252] ):-100/(100-perStockAbove50[252] )
twelveMonthSma20Weight  = bClose252Above20  ? 100/(perStockAbove20[252] ):-100/(100-perStockAbove20[252] )
twelveMonthWeight       = twelveMonthsma200_2Weight + twelveMonthSma150Weight + twelveMonthSma100Weight + twelveMonthsma50_2Weight + twelveMonthSma20Weight
// IBD's Formula for score without border (used to apply the cross product)
scoreWithoutBorder        =  W1Ma * (zeroMonthWeight + threeMonthWeight) + W2Ma * sixMonthWeight + W3Ma * nineMonthWeight + W4Ma * twelveMonthWeight
// Calculation of theorical max and min scores (Truncated because results are very very arround 50-60 otherwise)
// (The real formula of maxScore should be   maxScore =  W1Ma * (5*2*100/limitDown) + P2ma * (5*3*100/limitDown)  )
maxScore =  W1Ma * (2*100/limitDown) + W2Ma * (100/limitDown) + W3Ma * (100/limitDown) + W4Ma * (100/limitDown)
minScore = -(W1Ma * (2*100/(100-limitUp)) + W2Ma * (100/(100-limitUp)) +  W3Ma * (100/(100-limitUp)) + W4Ma * (100/(100-limitUp)) )
// Formula for score without border adjusted (for the min value to be equals 1)
adjustedScoreWithoutBorder = scoreWithoutBorder - minScore + 1
adjustedMaxScore           = maxScore - minScore +1
adjustedMinScore           = minScore - minScore +1
// Formula for score with border (cross product) - Result should not be greater than 99 and lower than 1 to this point
rsRating1 = math.round((adjustedScoreWithoutBorder)*99/(adjustedMaxScore-adjustedMinScore))
// Rendering the result (results are mainly distributed at the middle so to get a better result I try to get a wider range by adding to good and removing to bad one)
// Again results are distributed arround 1 to 75 so to get something linear I add to the score proportionally with their distance with 50 (only for better scores)
if(rsRating1>=50)
    truncate = (rsRating1-50)/2
    rsRating1 := math.round(rsRating1 + truncate)
if(rsRating1>99)
    rsRating1 := 99
if(rsRating1<1)
    rsRating1 := 1

// 2nd METHOD - No modification except limitation to 100% to master the limit and fix it further to 99 and 1 (and also because -100 is the max)
// Relative strength IBD style -> Initial Calculation against itslef
limitPerf = 2  // +/- 100% limitation
ThreeMthRS  = (closeDa/closeDa[63])
if(closeDa < closeDa[63])
    ThreeMthRS := -(1/ThreeMthRS) // to remove the same score than if this is a positive move
if(ThreeMthRS > limitPerf)
    ThreeMthRS := limitPerf
if(ThreeMthRS < -limitPerf)
    ThreeMthRS := -limitPerf
SixMthRS    = (closeDa/closeDa[126])
if(closeDa < closeDa[126])
    SixMthRS := -(1/SixMthRS)
if(SixMthRS > limitPerf)
    SixMthRS := limitPerf
if(SixMthRS < -limitPerf)
    SixMthRS := -limitPerf
NineMthRS   = (closeDa/closeDa[189])
if(closeDa < closeDa[189])
    NineMthRS := -(1/NineMthRS)
if(NineMthRS > limitPerf)
    NineMthRS := limitPerf
if(NineMthRS < -limitPerf)
    NineMthRS := -limitPerf
TwelveMthRS = (closeDa/closeDa[252])
if(closeDa < closeDa[252])
    TwelveMthRS := -(1/TwelveMthRS)
if(TwelveMthRS > limitPerf)
    TwelveMthRS := limitPerf
if(TwelveMthRS < -limitPerf)
    TwelveMthRS := -limitPerf
// Calculation of theorical max and min scores
maxScore2 = limitPerf*W1P + limitPerf*W2P + limitPerf*W3P + limitPerf*W4P
minScore2 = -limitPerf*W1P - limitPerf*W2P - limitPerf*W3P - limitPerf*W4P
// Calulation of Score
RSraw = W1P * ThreeMthRS + W2P * SixMthRS + W3P * NineMthRS + W4P * TwelveMthRS
// Adjustment (used to apply the cross product)
adjustedPerfScoreWithoutBorder = RSraw - minScore2 + 1
adjustedPerfMaxScore           = maxScore2 - minScore2 + 1
adjustedPerfMinScore           = minScore2 - minScore2 + 1
// Formula for score with border (cross product)
rsRating2 = math.round((adjustedPerfScoreWithoutBorder)*99/(adjustedPerfMaxScore-adjustedPerfMinScore))
// Rendering the result
if(rsRating2>=50)
    truncate = (rsRating2-50)/2
    rsRating2 := math.round(rsRating2 + truncate)
if(rsRating2>99)
    rsRating2 := 99
if(rsRating2<1)
    rsRating2 := 1



// 3RD METHODE
// I was running the average of both precedent results and... I found it was actually not that bad!
// But something was missing, a score for relative strenght against the SPX500.
// Let's do it
// Here I wanted to compare perf of ticker vs perf of spx500
// Limited at 100% of original calculation (I use a limit to determine maxscore and minscore and not go above 99 or under 1)
perfTicker63  = closeDa/closeDa[63]
perfComp63    = spxCloseDa/spxCloseDa[63]
perfTicker126 = closeDa/closeDa[126]
perfComp126   = spxCloseDa/spxCloseDa[126]
perfTicker189 = closeDa/closeDa[189]
perfComp189   = spxCloseDa/spxCloseDa[189]
perfTicker252 = closeDa/closeDa[252]
perfComp252   = spxCloseDa/spxCloseDa[252]
// Calculation of relative/comparative performance
limiteComp = 2 // +/- 100% limitation
spxThreeMthRS  = ( perfTicker63/perfComp63 )
if(perfTicker63 < perfComp63)
    spxThreeMthRS := -(1/spxThreeMthRS)
if(spxThreeMthRS > limiteComp)
    spxThreeMthRS := limiteComp
if(spxThreeMthRS < -limiteComp)
    spxThreeMthRS := -limiteComp
spxSixMthRS    = ( perfTicker126/perfComp126 )
if(perfTicker126 < perfComp126)
    spxSixMthRS := -(1/spxSixMthRS)
if(spxSixMthRS > limiteComp)
    spxSixMthRS := limiteComp
if(spxSixMthRS < -limiteComp)
    spxSixMthRS := -limiteComp
spxNineMthRS   = (perfTicker189/perfComp189)
if(perfTicker189 < perfComp189)
    spxNineMthRS := -(1/spxNineMthRS)
if(spxNineMthRS > limiteComp)
    spxNineMthRS := limiteComp
if(spxNineMthRS < -limiteComp)
    spxNineMthRS := -limiteComp
spxTwelveMthRS = ( perfTicker252/perfComp252 )
if(perfTicker252 < perfComp252)
    spxTwelveMthRS := -(1/spxTwelveMthRS)
if(spxTwelveMthRS > limiteComp)
    spxTwelveMthRS := limiteComp
if(spxTwelveMthRS < -limiteComp)
    spxTwelveMthRS := -limiteComp
// Calculation of theorical max and min scores
spxMaxScore2 = limiteComp*spxW1Ma + limiteComp*spxW2Ma + limiteComp*spxW3Ma + limiteComp*spxW4Ma
spxMinScore2 = -limiteComp*spxW1Ma - limiteComp*spxW2Ma - limiteComp*spxW3Ma - limiteComp*spxW4Ma
// Calulation of Score
spxRSraw = spxW1Ma * spxThreeMthRS + spxW2Ma * spxSixMthRS + spxW3Ma * spxNineMthRS + spxW4Ma * spxTwelveMthRS
// Adjustment (used to apply the cross product)
spxAdjustedPerfScoreWithoutBorder = spxRSraw - spxMinScore2 + 1
spxAdjustedPerfMaxScore           = spxMaxScore2 - spxMinScore2 + 1
spxAdjustedPerfMinScore           = spxMinScore2 - spxMinScore2 + 1
// Formula for score with border (cross product)
rsRating3 = math.round((spxAdjustedPerfScoreWithoutBorder)*99/(spxAdjustedPerfMaxScore-spxAdjustedPerfMinScore))
// Combination of both systems (w1, w2, are weight to give to the 3 methods)
float totalRsRating = math.round((w1 * rsRating1 + w2 * rsRating2 + w3 * rsRating3) / (w1 + w2 + w3))  // Combining the 3 methods

// Score adjustment based on observation among vaste amount of examples against IBD's ranking
// This is handiwork, if you want to work on improving the code you should remove this part
if(rsRating3<45 and rsRating3<rsRating1 and rsRating3<rsRating2) // When we have a great historic score, a great performance but a poor relative strenght, most of the time the rating decrease
    totalRsRating := math.round((w2 * rsRating2 + w3 * rsRating3) / (w2 + w3))
if(rsRating2>80 and rsRating1<70 and rsRating3>=68)// Many time when the stock is beaten down but have a huge momentum, this rating is down 20-30 points.
    totalRsRating := rsRating2-1                   // so we modify the score in this case to take into consideration only the RS Score which is usually not that bad alone at this moment
if(rsRating2>=59 and rsRating1<=30 and rsRating3>=50)// Many time when the stock is beaten down but have a huge/correct momentum, this rating is down 20-30 points.
    totalRsRating := rsRating2-1                     // And very often the RsRating is the closer to the final result
if(rsRating1>=80 and rsRating2>=49 and rsRating2<=65 and rsRating3<=45 and rsRating3>=33 and rsRating2-rsRating3>=6) // Sometimes when rsRating 2 & 3 are in between a given range, results seems OK. Exception here
    totalRsRating := math.round((w1 * rsRating1 + w2 * rsRating2 + w3 * rsRating3) / (w1 + w2 + w3 ))            // due to the first adjustment but still the first enhances and the second two


// Display the RS Rating
// Results are only acceptable in Daily TimeFrame
isDaily = timeframe.isdaily
labelText1 = "RS Rating"
labelText2 = "\n\n"+str.tostring(totalRsRating,"#0")
if(isDaily)
    labelText2 := "\n\n"+str.tostring(totalRsRating,"#0")
else
    labelText2 := ""
label1 = (hideRSRat == false) and barstate.islast ? label.new(bar_index, rs, text=labelText1 , color = color.rgb(0,0,0,100), size=size.normal, textcolor=colorRS, style=label.style_label_left, textalign=text.align_left, yloc=yloc.price) : na
label2 = (hideRSRat == false) and barstate.islast ? label.new(bar_index, rs, text=labelText2 , color = color.rgb(0,0,0,100), size=size.large, textcolor=colorRS, style=label.style_label_left, textalign=text.align_left, yloc=yloc.price) : na



// Not compatible with my modifications for now----------

//For 4 Year high and low on weekly the value is 244, For 52 week the value can be set as 52 and accordingly
// Barsback  = input(233,title="No of Bars Back")
// // calcs high x number days back
// hb = highestbars(rs, Barsback)
// // calcs low x number days back
// lb = lowestbars(rs, Barsback)

// // I remove the dot for the moment because when we modify the scale they aren't stick on the rs line
// //plots shape on chart at high - Green Dot
// if(hb!=hb[1])
//     label.new()
// plotshape(hb, title = "High", location= location.top, color=#0066ff , offset=hb, size = size.tiny, show_last=1, style=shape.circle)
// //plots shape on chart at low - Red Dot
// plotshape(lb, title = "Low", location= location.bottom, color=#ff0000 , offset=lb, size = size.tiny, show_last=1, style=shape.circle)



//------------------  EPS & Sales Part  ---------------------//
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Fred6724
// === USER INPUTS ====
i_displayTable = input(false, title='Hide Table', inline="1", group="----------EPS & Sales----------")
i_ArrowOnGraph = input(true,  title='Displays Arrows', inline="1", group="----------EPS & Sales----------")
i_salesOnGraph = input(false, title='Sales', inline="1", group="----------EPS & Sales----------")
i_arrowColor   = input(color.rgb(0,0,0,0), title='Arrow Colors', inline="2", group="----------EPS & Sales----------")
i_posArrowColor= input(color.rgb(13,7,201,0), title='Arrow +', group="----------EPS & Sales----------", inline="2")
i_negArrowColor= input(color.red, title='Arrow -', group="----------EPS & Sales----------", inline="2")
i_moreData     = input(true, title='More Quarters' ,group="----------EPS & Sales----------")
i_grossMargin  = input(false, title='Displays Gross Margin' ,group="----------EPS & Sales----------" ,inline="3")
i_ROE          = input(false, title='Displays Return On Equity' ,group="----------EPS & Sales----------" ,inline="3")
i_tableSize    = input.string(size.normal, title='Table Size', options=[size.tiny,size.small,size.normal, size.large] ,group="----------EPS & Sales----------" ,inline="4")
i_posTable = input.string(defval=position.bottom_left, title='Table Position', options=[position.top_left,position.top_center,position.top_right, position.middle_left, position.middle_center, position.middle_right, position.bottom_left, position.bottom_center, position.bottom_right] ,group="----------EPS & Sales----------" ,inline="4")
i_RowAndColumnColor = color.white
i_resultBackgroundColorOdd  = color.white
i_resultBackgroundColorEven = color.rgb(192,192,192,0)
i_RowAndColumnTextColor  = input(color.black, title='Sideways Row & Column Text Color' ,group="----------EPS & Sales----------")
i_posColor = input(color.rgb(13,7,201,0), title='% Positive Text Color' ,group="----------EPS & Sales----------", inline="5")
i_negColor = input(color.red, title='% Negative Text Color' ,group="----------EPS & Sales----------", inline="5")
// Not input
datasize = 10
blankUnderUp = i_moreData == true ? 3 : 6 // Because there is a blank between the top of the table and the second line but Tradingview doesn't display it.


// Declare table
var table epsTable = table.new(i_posTable, 15, 15, frame_color = color.rgb(0, 0, 0), frame_width = 1, border_width=0, border_color=color.rgb(0, 0, 0))


// === FUNCTIONS AND CALCULATIONS ===.
// Current earnings per share
// Modified line to get (actual) and (standard) earnings with 'request.earnings'. HUGE key point here to have closer results to IBD - MarketSmith
EPS = request.earnings(syminfo.tickerid, earnings.actual, ignore_invalid_symbol=true, lookahead = barmerge.lookahead_on)
EPS_Standard = request.earnings(syminfo.tickerid, earnings.standardized, ignore_invalid_symbol=true, lookahead = barmerge.lookahead_on)
EPS_Estimate = request.earnings(syminfo.tickerid, earnings.estimate, ignore_invalid_symbol=true, lookahead = barmerge.lookahead_on) // To reduce the probability of not detecting a change if EPS are the same quarters over quarters
SALES = request.financial(syminfo.tickerid, "TOTAL_REVENUE", "FQ")
grossMargin = i_grossMargin ? request.financial(syminfo.tickerid, "GROSS_MARGIN", "FQ"):na
ROE = request.financial(syminfo.tickerid, "RETURN_ON_EQUITY", "FQ")
//Date
rev = request.financial(syminfo.tickerid,'TOTAL_REVENUE','FQ',barmerge.gaps_on, ignore_invalid_symbol=true)


// GET EPS NUMBERS FROM TRADINGVIEW
EPSTime = ta.barssince(EPS != EPS[1] or EPS_Standard != EPS_Standard[1] or EPS_Estimate != EPS_Estimate[1]) == 0 // To reduce the probability of not detecting a change if EPS are the same quarters over quarters
// If the number of (bars since the value of EPS, is different, from previous EPS) equals 0, we are in an EPS event. (You can do it)
// (Better method, using the time since the last public EPS/Sales (Before we were using default 3M that was causing errors in case of non-regular period publishing))
// Now we are using sometimes Actual EPS, somtimes Standard EPS, based on my observations with MarketSmith numbers.
// Actual EPS
actualEPS  = ta.valuewhen(EPSTime, EPS, 0)
actualEPS1 = ta.valuewhen(EPSTime, EPS, 1) // With "1" to search the previous EPS value, etc
actualEPS2 = ta.valuewhen(EPSTime, EPS, 2)
actualEPS3 = ta.valuewhen(EPSTime, EPS, 3)
actualEPS4 = ta.valuewhen(EPSTime, EPS, 4)
actualEPS5 = ta.valuewhen(EPSTime, EPS, 5)
actualEPS6 = ta.valuewhen(EPSTime, EPS, 6)
actualEPS7 = ta.valuewhen(EPSTime, EPS, 7)
actualEPS8 = ta.valuewhen(EPSTime, EPS, 8)
actualEPS9  = ta.valuewhen(EPSTime, EPS, 9)
actualEPS10 = ta.valuewhen(EPSTime, EPS, 10)
actualEPS11 = ta.valuewhen(EPSTime, EPS, 11)
// Standard EPS
standardEPS   = ta.valuewhen(EPSTime, EPS_Standard, 0) 
standardEPS1  = ta.valuewhen(EPSTime, EPS_Standard, 1) 
standardEPS2  = ta.valuewhen(EPSTime, EPS_Standard, 2)
standardEPS3  = ta.valuewhen(EPSTime, EPS_Standard, 3)
standardEPS4  = ta.valuewhen(EPSTime, EPS_Standard, 4)
standardEPS5  = ta.valuewhen(EPSTime, EPS_Standard, 5)
standardEPS6  = ta.valuewhen(EPSTime, EPS_Standard, 6)
standardEPS7  = ta.valuewhen(EPSTime, EPS_Standard, 7)
standardEPS8  = ta.valuewhen(EPSTime, EPS_Standard, 8)
standardEPS9  = ta.valuewhen(EPSTime, EPS_Standard, 9)
standardEPS10 = ta.valuewhen(EPSTime, EPS_Standard, 10)
standardEPS11 = ta.valuewhen(EPSTime, EPS_Standard, 11)

// Same with Sales  
sales   = ta.valuewhen(EPSTime, SALES, 0)
sales1  = ta.valuewhen(EPSTime, SALES, 1)
sales2  = ta.valuewhen(EPSTime, SALES, 2)
sales3  = ta.valuewhen(EPSTime, SALES, 3)
sales4  = ta.valuewhen(EPSTime, SALES, 4)
sales5  = ta.valuewhen(EPSTime, SALES, 5)
sales6  = ta.valuewhen(EPSTime, SALES, 6)
sales7  = ta.valuewhen(EPSTime, SALES, 7)
sales8  = ta.valuewhen(EPSTime, SALES, 8)
sales9  = ta.valuewhen(EPSTime, SALES, 9)
sales10 = ta.valuewhen(EPSTime, SALES, 10)
sales11 = ta.valuewhen(EPSTime, SALES, 11)

// Detect same sales for TradingView bug correction on the EPS Da (Same sales than previous display)
bool sameSales = sales==sales1

// Function to define previous quarters gross margin & roe (Less precise than EPS and Sales Data)
f_grossMargin(i) =>
    request.security(syminfo.tickerid, '3M', grossMargin[i])
f_roe(i) =>
    request.security(syminfo.tickerid, '3M', ROE[i])
    
// Calculation using IBD/Marketsmith principle : current quarter EPS vs the same quartar's EPS of previous year. (YoY) 
EpsChange0  = actualEPS  < 0 and actualEPS4  <= 0 ? na: actualEPS4  < 0 and standardEPS4  > 0 ? (EPS-standardEPS4)/math.abs(standardEPS4)*100:EPS< 0 and actualEPS4  > 0 ? na:(EPS-actualEPS4)        /math.abs(actualEPS4)*100
EpsChange1  = actualEPS1 < 0 and actualEPS5  <= 0 ? na: actualEPS5  < 0 and standardEPS5  > 0 ? (standardEPS1-standardEPS5)/math.abs(standardEPS5)*100:actualEPS1 < 0 and actualEPS5  > 0 ? na:(actualEPS1-actualEPS5) /math.abs(actualEPS5)*100
EpsChange2  = actualEPS2 < 0 and actualEPS6  <= 0 ? na: actualEPS6  < 0 and standardEPS6  > 0 ? (standardEPS2-standardEPS6)/math.abs(standardEPS6)*100:actualEPS2 < 0 and actualEPS6  > 0 ? na:(actualEPS2-actualEPS6) /math.abs(actualEPS6)*100
EpsChange3  = actualEPS3 < 0 and actualEPS7  <= 0 ? na: actualEPS7  < 0 and standardEPS7  > 0 ? (standardEPS3-standardEPS7)/math.abs(standardEPS7)*100:actualEPS3 < 0 and actualEPS7  > 0 ? na:(actualEPS3-actualEPS7) /math.abs(actualEPS7)*100
EpsChange4  = actualEPS4 < 0 and actualEPS8  <= 0 ? na: actualEPS8  < 0 and standardEPS8  > 0 ? (standardEPS4-standardEPS8)/math.abs(standardEPS8)*100:actualEPS4 < 0 and actualEPS8  > 0 ? na:(actualEPS4-actualEPS8) /math.abs(actualEPS8)*100
EpsChange5  = actualEPS5 < 0 and actualEPS9  <= 0 ? na: actualEPS9  < 0 and standardEPS9  > 0 ? (standardEPS5-standardEPS9)/math.abs(standardEPS9)*100:actualEPS5 < 0 and actualEPS9  > 0 ? na:(actualEPS5-actualEPS9) /math.abs(actualEPS9)*100
EpsChange6  = actualEPS6 < 0 and actualEPS10 <= 0 ? na: actualEPS10 < 0 and standardEPS10 > 0 ? (standardEPS6-standardEPS10)/math.abs(standardEPS10)*100:actualEPS6 < 0 and actualEPS10 > 0 ? na:(actualEPS6-actualEPS10)/math.abs(actualEPS10)*100
EpsChange7  = actualEPS7 < 0 and actualEPS11 <= 0 ? na: actualEPS11 < 0 and standardEPS11 > 0 ? (standardEPS7-standardEPS11)/math.abs(standardEPS11)*100:actualEPS7 < 0 and actualEPS11 > 0 ? na:(actualEPS7-actualEPS11)/math.abs(actualEPS11)*100
// The case in which atual was - and standard was + was not taken into account, I added a condition to fix a ver low value in this case and have the '#' succesfully display
// because of the choice when fillCell.

// When EPS is negative we take the closer from 0 between standardized and reported
// We also use another variable to recognize when the calculation has been done with negative EPS (To display '#')                                                                                  // added this condition because 0.98 vs -0.16 = #712/713% not 999% APA
EpsChangeHash0 = actualEPS4  >= 0 ? na: actualEPS < 0 and standardEPS4  < 0 ? na:actualEPS4  < 0 and standardEPS4  > 0 ? (EPS-actualEPS4)        /math.abs(actualEPS4) *100:actualEPS4  <= standardEPS4  and standardEPS4 >-0.01 ? (EPS-standardEPS4)        /math.abs(standardEPS4)*100:(EPS-actualEPS4)/math.abs(actualEPS4)*100
EpsChangeHash1 = actualEPS5  >= 0 ? na:actualEPS1 < 0 and standardEPS5  < 0 ? na:actualEPS5  < 0 and standardEPS5  > 0 ? (actualEPS1-actualEPS5) /math.abs(actualEPS5) *100:actualEPS5  <= standardEPS5  and standardEPS5 >-0.01 ? (actualEPS1-standardEPS5) /math.abs(standardEPS5) *100:(actualEPS1-actualEPS5) /math.abs(actualEPS5) *100
EpsChangeHash2 = actualEPS6  >= 0 ? na:actualEPS2 < 0 and standardEPS6  < 0 ? na:actualEPS6  < 0 and standardEPS6  > 0 ? (actualEPS2-actualEPS6) /math.abs(actualEPS6) *100:actualEPS6  <= standardEPS6  and standardEPS6 >-0.01 ? (actualEPS2-standardEPS6) /math.abs(standardEPS6) *100:(actualEPS2-actualEPS6) /math.abs(actualEPS6) *100
EpsChangeHash3 = actualEPS7  >= 0 ? na:actualEPS3 < 0 and standardEPS7  < 0 ? na:actualEPS7  < 0 and standardEPS7  > 0 ? (actualEPS3-actualEPS7) /math.abs(actualEPS7) *100:actualEPS7  <= standardEPS7  and standardEPS7 >-0.01 ? (actualEPS3-standardEPS7) /math.abs(standardEPS7) *100:(actualEPS3-actualEPS7) /math.abs(actualEPS7) *100
EpsChangeHash4 = actualEPS8  >= 0 ? na:actualEPS4 < 0 and standardEPS8  < 0 ? na:actualEPS8  < 0 and standardEPS8  > 0 ? (actualEPS4-actualEPS8) /math.abs(actualEPS8) *100:actualEPS8  <= standardEPS8  and standardEPS8 >-0.01 ? (actualEPS4-standardEPS8) /math.abs(standardEPS8) *100:(actualEPS4-actualEPS8) /math.abs(actualEPS8) *100
EpsChangeHash5 = actualEPS9  >= 0 ? na:actualEPS5 < 0 and standardEPS9  < 0 ? na:actualEPS9  < 0 and standardEPS9  > 0 ? (actualEPS5-actualEPS9) /math.abs(actualEPS9) *100:actualEPS9  <= standardEPS9  and standardEPS9 >-0.01 ? (actualEPS5-standardEPS9) /math.abs(standardEPS9) *100:(actualEPS5-actualEPS9) /math.abs(actualEPS9) *100
EpsChangeHash6 = actualEPS10 >= 0 ? na:actualEPS6 < 0 and standardEPS10 < 0 ? na:actualEPS10 < 0 and standardEPS10 > 0 ? (actualEPS6-actualEPS10)/math.abs(actualEPS10)*100:actualEPS10 <= standardEPS10 and standardEPS10>-0.01 ? (actualEPS6-standardEPS10)/math.abs(standardEPS10)*100:(actualEPS6-actualEPS10)/math.abs(actualEPS10)*100
EpsChangeHash7 = actualEPS11 >= 0 ? na:actualEPS7 < 0 and standardEPS11 < 0 ? na:actualEPS11 < 0 and standardEPS11 > 0 ? (actualEPS7-actualEPS11)/math.abs(actualEPS11)*100:actualEPS11 <= standardEPS11 and standardEPS11>-0.01 ? (actualEPS7-standardEPS11)/math.abs(standardEPS11)*100:(actualEPS7-actualEPS11)/math.abs(actualEPS11)*100

// EPS QoQ (To prevent me from harassment in the comments :-) ... )
EpsChangeQoQ0 = (actualEPS -actualEPS1)/math.abs(actualEPS1)*100
EpsChangeQoQ1 = (actualEPS1-actualEPS2)/math.abs(actualEPS2)*100
EpsChangeQoQ2 = (actualEPS2-actualEPS3)/math.abs(actualEPS3)*100
EpsChangeQoQ3 = (actualEPS3-actualEPS4)/math.abs(actualEPS4)*100
EpsChangeQoQ4 = (actualEPS4-actualEPS5)/math.abs(actualEPS5)*100
EpsChangeQoQ5 = (actualEPS5-actualEPS6)/math.abs(actualEPS6)*100
EpsChangeQoQ6 = (actualEPS6-actualEPS7)/math.abs(actualEPS7)*100
EpsChangeQoQ7 = (actualEPS7-actualEPS8)/math.abs(actualEPS8)*100

// Sales QoQ
salesChangeQoQ0 = (sales  -sales1) /math.abs(sales1) *100
salesChangeQoQ1 = (sales1 -sales2) /math.abs(sales2) *100
salesChangeQoQ2 = (sales2 -sales3) /math.abs(sales3) *100
salesChangeQoQ3 = (sales3 -sales4) /math.abs(sales4) *100
salesChangeQoQ4 = (sales4 -sales5) /math.abs(sales5) *100
salesChangeQoQ5 = (sales5 -sales6) /math.abs(sales6) *100
salesChangeQoQ6 = (sales6 -sales7) /math.abs(sales7) *100
salesChangeQoQ7 = (sales7 -sales8) /math.abs(sales8) *100


//Adapting Format of Sales 98 000 000 to 98,0 M 
Sales0M  = (sales /1000000)
Sales1M  = (sales1/1000000)
Sales2M  = (sales2/1000000)
Sales3M  = (sales3/1000000)
Sales4M  = (sales4/1000000)
Sales5M  = (sales5/1000000)
Sales6M  = (sales6/1000000)
Sales7M  = (sales7/1000000)
Sales8M  = (sales8/1000000)
Sales9M  = (sales9/1000000)
Sales10M = (sales10/1000000)
Sales11M = (sales11/1000000)

// If sales > 1000M we want it to be display in $Bil
if(sales >= 10000000000)
    Sales0M  := (sales /1000000000)
    Sales1M  := (sales1/1000000000)
    Sales2M  := (sales2/1000000000)
    Sales3M  := (sales3/1000000000)
    Sales4M  := (sales4/1000000000)
    Sales5M  := (sales5/1000000000)
    Sales6M  := (sales6/1000000000)
    Sales7M  := (sales7/1000000000)
    Sales8M  := (sales8/1000000000)
    Sales9M  := (sales9/1000000000)
    Sales10M := (sales10/1000000000)
    Sales11M := (sales11/1000000000)


// Calculation of % of change sales year over year (YoY)
salesChange0  = (sales -sales4) /math.abs(sales4) *100
salesChange1  = (sales1-sales5) /math.abs(sales5) *100
salesChange2  = (sales2-sales6) /math.abs(sales6) *100
salesChange3  = (sales3-sales7) /math.abs(sales7) *100
salesChange4  = (sales4-sales8) /math.abs(sales8) *100
salesChange5  = (sales5-sales9) /math.abs(sales9) *100
salesChange6  = (sales6-sales10)/math.abs(sales10)*100
salesChange7  = (sales7-sales11)/math.abs(sales11)*100



// === TABLE FUNCTIONS === (Used for cells completion)
// Each function changes the display format in the cells
f_fillCell(_table, _column, _row, _value) =>
    _c_color = i_posColor
    _transp = 0
    _cellText = str.tostring(_value, '0.00')
    if(_cellText == 'NaN')
        _cellText := 'N/A'
    myColor = _row == 10 or _row == 8 or _row == 6 or _row == 4 ? i_resultBackgroundColorOdd:i_resultBackgroundColorEven
    table.cell(_table, _column, _row, _cellText, bgcolor=color.new(myColor, 0), text_color=i_RowAndColumnTextColor,text_size=i_tableSize)

// To have one digit after coma for sales    
f_fillCell2(_table, _column, _row, _value) =>
    _c_color = i_posColor
    _transp = 0
    _cellText = str.tostring(_value, '0.0')
    if(_cellText == 'NaN')
        _cellText := 'N/A'
    myColor = _row == 10 or _row == 8 or _row == 6 or _row == 4 ? i_resultBackgroundColorOdd:i_resultBackgroundColorEven
    table.cell(_table, _column, _row, _cellText, bgcolor=color.new(myColor, 0), text_color=i_RowAndColumnTextColor,text_size=i_tableSize)

// For Sales comparison    
f_fillCell2SALES(_table, _column, _row, _value, _value1) =>
    _c_color = i_posColor
    _transp = 0
    _cellText1 = str.tostring(_value, '0.0')
    _cellText2 = str.tostring(_value1,'0.0')
    if(_cellText1 == 'NaN')
        _cellText1 := 'N/A'
    if(_cellText2 == 'NaN')
        _cellText2 := 'N/A'
    _cellText  =  _cellText1 + ' vs ' + _cellText2
    myColor = _row == 10 or _row == 8 or _row == 6 or _row == 4 ? i_resultBackgroundColorOdd:i_resultBackgroundColorEven
    table.cell(_table, _column, _row, _cellText, bgcolor=color.new(myColor, 0), text_color=i_RowAndColumnTextColor,text_size=i_tableSize)

// EPS comparison (Only used to compare EPS for calculation with a 'if' further)
f_fillCellEPS(_table, _column, _row, _value, _value1) =>
    _c_color = i_posColor
    _transp = 0
    _cellText1 = str.tostring(_value, '0.00')
    _cellText2 = str.tostring(_value1,'0.00')
    if(_cellText1 == 'NaN')
        _cellText1 := 'N/A'
    if(_cellText2 == 'NaN')
        _cellText2 := 'N/A'
    _cellText  =  _cellText1 + ' vs ' + _cellText2
    myColor = _row == 10 or _row == 8 or _row == 6 or _row == 4 ? i_resultBackgroundColorOdd:i_resultBackgroundColorEven
    table.cell(_table, _column, _row, _cellText, bgcolor=color.new(myColor, 0), text_color=i_RowAndColumnTextColor,text_size=i_tableSize)
    
f_fillCellComp(_table, _column, _row, _value) =>
    _c_color = _value >= 0 ? i_posColor : i_negColor
    _transp = 0
    // Recent modification made that I need to put the IBD/MarketSmith limitaton of +999% here
    _cellText = _value > 999 ? '+999%':_value > 0 ? '+' + str.tostring(_value, '0') + '%':str.tostring(_value, '0') + '%'
    if(_cellText == 'NaN%')
        _cellText := 'N/A'
    if(_cellText == '+0%')
        _cellText := '0%'
    if(_value == EpsChangeHash0)
        _cellText := _value > 999 ? '#+999%':_value > 0 ? '#' +  '+' + str.tostring(_value, '0') + '%':'#' + str.tostring(_value, '0') + '%'
    if(_value == EpsChangeHash1)
        _cellText := _value > 999 ? '#+999%':_value > 0 ? '#' +  '+' + str.tostring(_value, '0') + '%':'#' + str.tostring(_value, '0') + '%'
    if(_value == EpsChangeHash2)
        _cellText := _value > 999 ? '#+999%':_value > 0 ? '#' +  '+' + str.tostring(_value, '0') + '%':'#' + str.tostring(_value, '0') + '%'
    if(_value == EpsChangeHash3)
        _cellText := _value > 999 ? '#+999%':_value > 0 ? '#' +  '+' + str.tostring(_value, '0') + '%':'#' + str.tostring(_value, '0') + '%'
    if(_value == EpsChangeHash4)
        _cellText := _value > 999 ? '#+999%':_value > 0 ? '#' +  '+' + str.tostring(_value, '0') + '%':'#' + str.tostring(_value, '0') + '%'
    if(_value == EpsChangeHash5)
        _cellText := _value > 999 ? '#+999%':_value > 0 ? '#' +  '+' + str.tostring(_value, '0') + '%':'#' + str.tostring(_value, '0') + '%'
    if(_value == EpsChangeHash6)
        _cellText := _value > 999 ? '#+999%':_value > 0 ? '#' +  '+' + str.tostring(_value, '0') + '%':'#' + str.tostring(_value, '0') + '%'
    if(_value == EpsChangeHash7)
        _cellText := _value > 999 ? '#+999%':_value > 0 ? '#' +  '+' + str.tostring(_value, '0') + '%':'#' + str.tostring(_value, '0') + '%'
    // Color for even or odd row
    myColor = _row == 10 or _row == 8 or _row == 6 or _row == 4 ? i_resultBackgroundColorOdd:i_resultBackgroundColorEven
    table.cell(_table, _column, _row, _cellText, bgcolor=color.new(myColor, 0), text_color=_cellText=='0%' or _cellText=='N/A'?i_RowAndColumnTextColor:_c_color,text_size=i_tableSize)

//For QoQ EPS%
f_fillCellComp2(_table, _column, _row, _value) =>
    _c_color = _value >= 0 ? i_posColor : i_negColor
    _transp = 0
    // Recent modification made that I need to put the IBD/MarketSmith limitaton of +999% here
    _cellText = _value > 999 ? '+999%':_value > 0 ? '+' + str.tostring(_value, '0') + '%':str.tostring(_value, '0') + '%'
    if(_cellText == 'NaN%')
        _cellText := 'N/A'
    // Color for even or odd row
    myColor = _row == 10 or _row == 8 or _row == 6 or _row == 4 ? i_resultBackgroundColorOdd:i_resultBackgroundColorEven
    table.cell(_table, _column, _row, _cellText, bgcolor=color.new(myColor, 0), text_color=_cellText=='N/A'?i_RowAndColumnTextColor:_c_color,text_size=i_tableSize)
    
// Function for Date
f_array(arrayId, val) => 
    array.unshift(arrayId, val) // append vale to an array
    array.pop(arrayId)

ftdate(_table, _column, _row, _value) => 
    myColor = _row == 10 or _row == 8 or _row == 6 or _row == 4 ? i_resultBackgroundColorOdd:i_resultBackgroundColorEven
    table.cell(table_id = _table, column = _column, row = _row, text = _value, bgcolor = myColor, text_color = i_RowAndColumnTextColor, text_size = i_tableSize)
// For Date
var date = array.new_int(datasize)
if rev
    f_array(date, time)


// Display table 
condRepeatSameValueAtLastLine = actualEPS==actualEPS1 and standardEPS==standardEPS1 and EPS_Estimate==EPS_Estimate[1] // here I use 'and' instead of 'or' because we want to avoid the display bug of TradingView when the 2 last lines repeat themselves
if barstate.islast and not i_displayTable
    // EPS DISPLAY
    f_fillCell(epsTable, 1, 10, condRepeatSameValueAtLastLine ? na:EPS)
    f_fillCell(epsTable, 1, 9, actualEPS1)
    f_fillCell(epsTable, 1, 8, actualEPS2)
    f_fillCell(epsTable, 1, 7, actualEPS3)
    f_fillCell(epsTable, 1, 6, actualEPS4)
    if(i_moreData == true)
        f_fillCell(epsTable, 1, 5, actualEPS5)
        f_fillCell(epsTable, 1, 4, actualEPS6)
        f_fillCell(epsTable, 1, 3, actualEPS7)
    // % CHANGE EPS
    // Here I compared math function of (a-b)/b with B negative and noticed that the result we want is always the greatest (closer to 0 in this case)
    if(i_moreData == true)
        f_fillCellComp(epsTable, 2, 3, EpsChangeHash7 > EpsChange7 ? EpsChangeHash7:EpsChange7)
        f_fillCellComp(epsTable, 2, 4, EpsChangeHash6 > EpsChange6 ? EpsChangeHash6:EpsChange6)
        f_fillCellComp(epsTable, 2, 5, EpsChangeHash5 > EpsChange5 ? EpsChangeHash5:EpsChange5)
    f_fillCellComp(epsTable, 2, 6, EpsChangeHash4 > EpsChange4 ? EpsChangeHash4:EpsChange4)
    f_fillCellComp(epsTable, 2, 7, EpsChangeHash3 > EpsChange3 ? EpsChangeHash3:EpsChange3)
    f_fillCellComp(epsTable, 2, 8, EpsChangeHash2 > EpsChange2 ? EpsChangeHash2:EpsChange2)
    f_fillCellComp(epsTable, 2, 9, EpsChangeHash1 > EpsChange1 ? EpsChangeHash1:EpsChange1)
    f_fillCellComp(epsTable, 2, 10, condRepeatSameValueAtLastLine ? na:EpsChangeHash0 > EpsChange0 ? EpsChangeHash0:EpsChange0)
    
    
    //SALES DISPLAY
    f_fillCell2(epsTable, 3, 10, condRepeatSameValueAtLastLine ? na:(EPSTime or EPSTime[1]) and sameSales ? na:Sales0M)
    f_fillCell2(epsTable, 3, 9, Sales1M)
    f_fillCell2(epsTable, 3, 8, Sales2M)
    f_fillCell2(epsTable, 3, 7, Sales3M)
    f_fillCell2(epsTable, 3, 6, Sales4M)
    if(i_moreData == true)
        f_fillCell2(epsTable, 3, 5, Sales5M)
        f_fillCell2(epsTable, 3, 4, Sales6M)
        f_fillCell2(epsTable, 3, 3, Sales7M) 
    // % CHANGE SALES
    if(i_moreData == true)
        f_fillCellComp(epsTable, 4, 3, salesChange7)
        f_fillCellComp(epsTable, 4, 4, salesChange6)
        f_fillCellComp(epsTable, 4, 5, salesChange5)
    f_fillCellComp(epsTable, 4, 6, salesChange4)
    f_fillCellComp(epsTable, 4, 7, salesChange3)
    f_fillCellComp(epsTable, 4, 8, salesChange2)
    f_fillCellComp(epsTable, 4, 9, salesChange1)
    f_fillCellComp(epsTable, 4, 10, condRepeatSameValueAtLastLine ? na:(EPSTime or EPSTime[1]) and sameSales ? na:salesChange0)

    // GROSS MARGIN 
    if(i_grossMargin == true)
        if(i_moreData == true)
            f_fillCellComp(epsTable, 5, 3, f_grossMargin(7))
            f_fillCellComp(epsTable, 5, 4, f_grossMargin(6))
            f_fillCellComp(epsTable, 5, 5, f_grossMargin(5))
        f_fillCellComp(epsTable, 5, 6, f_grossMargin(4))
        f_fillCellComp(epsTable, 5, 7, f_grossMargin(3))
        f_fillCellComp(epsTable, 5, 8, f_grossMargin(2))
        f_fillCellComp(epsTable, 5, 9, f_grossMargin(1))
        f_fillCellComp(epsTable, 5, 10, grossMargin)
        
    // ROE
    if(i_ROE == true)
        if(i_moreData == true)
            f_fillCellComp(epsTable, 6, 3, f_roe(7))
            f_fillCellComp(epsTable, 6, 4, f_roe(6))
            f_fillCellComp(epsTable, 6, 5, f_roe(5))
        f_fillCellComp(epsTable, 6, 6, f_roe(4))
        f_fillCellComp(epsTable, 6, 7, f_roe(3))
        f_fillCellComp(epsTable, 6, 8, f_roe(2))
        f_fillCellComp(epsTable, 6, 9, f_roe(1))
        f_fillCellComp(epsTable, 6, 10, ROE) 
    
    // For Date MMM-yy
    for i = 0 to datasize-blankUnderUp
        if barstate.islast
            ftdate(epsTable, 0, (datasize-i), str.format('{0, date, MMM-yy}', array.get(date, i)))

    

   
    //FOR HEADINGS

    txt6 = "   %Chg   " 
    txt8 = "Quarterly"
    txt9 = "     EPS($)   "
    
    txt10 = "Sales($Mil)"
    if(sales >= 10000000000)
        txt10 := "Sales($Bil)"
    txt11 = "     %Chg     " 
    txt12 = "   GM   "
    txt13 = "    ROE    "
 

    // Side Column
    table.cell(epsTable,2,0,  text=txt6,  bgcolor=i_RowAndColumnColor, text_color=i_RowAndColumnTextColor,text_size=i_tableSize)
    table.cell(epsTable,0,0, text=txt8, bgcolor=i_RowAndColumnColor, text_color=i_RowAndColumnTextColor,text_size=i_tableSize)
    table.cell(epsTable,1,0, text=txt9, bgcolor=i_RowAndColumnColor, text_color=i_RowAndColumnTextColor,text_size=i_tableSize)
    
    
    //SALES HEADING 
    table.cell(epsTable,3,0, text=txt10, bgcolor=i_RowAndColumnColor, text_color=i_RowAndColumnTextColor,text_size=i_tableSize)
    table.cell(epsTable,4,0, text=txt11, bgcolor=i_RowAndColumnColor, text_color=i_RowAndColumnTextColor,text_size=i_tableSize)
    
    //GROSS MARGIN   (table, line, row, txt..)
    if(i_grossMargin == true)
        table.cell(epsTable,5,0, text=txt12, bgcolor=i_RowAndColumnColor, text_color=i_RowAndColumnTextColor,text_size=i_tableSize)
    // ROE
    if(i_ROE == true)
        table.cell(epsTable,6,0, text=txt13, bgcolor=i_RowAndColumnColor, text_color=i_RowAndColumnTextColor,text_size=i_tableSize)
 
// Diplay Arrow on the graph with % variation EPS
selectEPS = ta.valuewhen(EPSTime, EpsChangeHash0, 0) > ta.valuewhen(EPSTime, EpsChange0, 0) // Time for Sales annoucement
EPSvalue   = selectEPS ? ta.valuewhen(EPSTime, EpsChangeHash0, 0):ta.valuewhen(EPSTime, EpsChange0, 0)
salesValue = ta.valuewhen(EPSTime, salesChange0, 0) // Select the value of % sales change for the date of the arrow
//plotshape(EPSTime, style=shape.triangleup, color=color.new(color.silver, 0), location=location.bottom, size=size.tiny, text="", textcolor = color.white)
textLayout1 = i_salesOnGraph ? 'EPS & Sales':'EPS'
textLayout2 = EPSvalue > 999 ? '\n+999%':EPSvalue > 0 ? '\n+' + str.tostring(EPSvalue, '0') + '%':'\n' + str.tostring(EPSvalue, '0') + '%'
if(textLayout2 == '\nNaN%')
    textLayout2 := '\nN/A'
if(textLayout2 == '\n+0%')
    textLayout2 := '\n0%'
textLayout4 = (EPSTime or EPSTime[1]) and sameSales and barstate.islast ? 'NaN%':salesChange0 > 999 ? '+999%':salesChange0 > 0 ? '+' + str.tostring(salesChange0, '0') + '%':str.tostring(salesChange0, '0') + '%' // For Sales
if(textLayout4 == 'NaN%')
    textLayout4 := 'N/A'
if(textLayout4 == '+0%')
    textLayout4 := '0%'
// Here we check if we have to plot sales or not, depending on the result we display appropriate variables
if(EPSTime and i_ArrowOnGraph)
    label1 = label.new(bar_index, bar_index, xloc=xloc.bar_index, yloc=yloc.belowbar, text=textLayout1, style=label.style_triangleup, color=color.new(color.aqua,100), textcolor=i_arrowColor, size=size.small)
    if(not i_salesOnGraph)
        label2 = label.new(bar_index, bar_index, xloc=xloc.bar_index, yloc=yloc.belowbar, text=textLayout2, style=label.style_triangleup, color=i_arrowColor,              textcolor=textLayout2=='\nN/A' or textLayout2=='\n0%' ? i_arrowColor:EPSvalue > -1 ? i_posArrowColor:i_negArrowColor, size=size.small)
    if(i_salesOnGraph)
        label2 = label.new(bar_index, bar_index, xloc=xloc.bar_index, yloc=yloc.belowbar, text=textLayout2+' | '+textLayout4, style=label.style_triangleup, color=i_arrowColor,              textcolor=textLayout2=='\nN/A' or textLayout2=='\n0%' ? i_arrowColor:EPSvalue > -1 ? i_posArrowColor:i_negArrowColor, size=size.small)



//------------------  Markerd Highs and Lows  ---------------------//

// Price Peak/Valley Points
// Highlights exact price at high or low points over a 19-period interval.
// For example, on a Daily chart, a High Price point is marked on the date
// where there has been no higher price the 9 days prior to that date and
// the 9 days following that date.

// Fuck it :')
// High Price Point
i_displayHL = input(true, title="Display H/L Points", group="----------High/Low Price Points----------")
if(timeframe.isdaily and i_displayHL)
    // condHighPricePointBefore = high[10] > high[11] and high[10] > high[12] and high[10] > high[13] and high[10] > high[14] and high[10] > high[15] and high[10] > high[16] and high[10] > high[17] and high[10] > high[18] and high[10] > high[19]
    // condHighPricePointAfter  = high[10] > high[9] and high[10] > high[8] and high[10] > high[7] and high[10] > high[6] and high[10] > high[5] and high[10] > high[4] and high[10] > high[3] and high[10] > high[2] and high[10] > high[1]
    condHighPricePointBefore = high[9] >= high[10] and high[9] >= high[11] and high[9] >= high[12] and high[9] >= high[13] and high[9] >= high[14] and high[9] >= high[15] and high[9] >= high[16] and high[9] >= high[17] and high[9] >= high[18]
    condHighPricePointAfter  = high[9] > high[8] and high[9] > high[7] and high[9] > high[6] and high[9] > high[5] and high[9] > high[4] and high[9] > high[3] and high[9] > high[2] and high[9] > high[1] and high[9] > high
    condHighPricePoint       = condHighPricePointBefore and condHighPricePointAfter
    if (condHighPricePoint)
        textHigh9  = str.tostring(high[9], '0.00')
        highestHigh = label.new(bar_index-9, high[9], xloc=xloc.bar_index, yloc=yloc.price, style=label.style_none, text=textHigh9, textcolor=color.rgb(0,0,0,0))
    // Low Price Point
    condLowPricePointBefore = low[9] <= low[10] and low[9] <= low[11] and low[9] <= low[12] and low[9] <= low[13] and low[9] <= low[14] and low[9] <= low[15] and low[9] <= low[16] and low[9] <= low[17] and low[9] <= low[18]
    condLowPricePointAfter  = low[9] < low[8] and low[9] < low[7] and low[9] < low[6] and low[9] < low[5] and low[9] < low[4] and low[9] < low[3] and low[9] < low[2] and low[9] < low[1] and low[9] < low
    condLowPricePoint       = condLowPricePointBefore and condLowPricePointAfter
    if (condLowPricePoint)
        textLow9  = str.tostring(low[9], '0.00')
        lowestLow  = label.new(bar_index-9, low[9], xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_center, text="\n" + textLow9, textcolor=color.rgb(0,0,0,0), color=color.rgb(0,0,0,100))

